---
title: "Working With Data"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=TRUE, eval=TRUE, comment=NA)
library(webexercises)
library(PASWR2)
library(knitr)
library(kableExtra)
library(ggplot2)
library(tidyverse)
```

```{r read1, echo = FALSE}
chol <- read.table(file = "Data/chol.txt", header = TRUE, fileEncoding = 'UTF-8-BOM')
education <- read.csv(file = "Data/edu.csv", na.strings = "*", fileEncoding = 'UTF-8-BOM')
```

## Checking variable types {#sec-checking}

Once a data frame has been read into R, it is always a good idea to examine its contents using the `str()` function to see the **structure** of the data object. We have already seen the `str()` function in [Lab 2](https://moodle.gla.ac.uk/pluginfile.php/9073095/mod_resource/content/2/02-data.html#sec-df){target="_blank"} but as a reminder, it shows us the type of vector each column in a data frame is saved as.

Running the following code tells us that the four variables `ldl`, `hdl`, `trig` and `age` are all integer vectors and that `id`, `gender` and `smoke` are character vectors.

::: panel-tabset
## R Code
```{r data1.1, eval = FALSE}
str(chol)
```

## Output
```{r data1.2, echo = FALSE}
str(chol)
```
:::

Because `gender` only takes the values `"female"` or `"male"` in this case, and `smoke` is categorised into three levels, `"no"`, `"ex-smoker"` and `"current"`, it makes sense to treat both these variables as factors instead of character vectors.

We can use what we learned in [Lab 2](https://moodle.gla.ac.uk/pluginfile.php/9073095/mod_resource/content/2/02-data.html#sec-fact){target="_blank"} to change these variables into factors. 

::: panel-tabset
## R Code
```{r data2}
chol$gender <- factor(x = chol$gender, levels = c("female", "male"))
chol$smoke <- factor(x = chol$smoke, levels = c("no", "ex-smoker", "current"))
```
:::

Now using `str()` to check the type of vector each column is saved as shows us that `gender` and `smoke` are both now factors.

::: panel-tabset
## R Code
```{r data3.1, eval = FALSE}
str(chol)
```

## Output
```{r data3.2, echo = FALSE}
str(chol)
```
:::

:::{.question}
::::{.question-header}
Task
::::
::::{.question-container .webex-check}
```{r data-ans1, echo=FALSE}
opts1 <- c("character", "logical", "numeric", answer="integer", "factor")
```
What type of variable is `schools` saved as in the `education` data frame?
`r mcq(opts1)`

`r hide("Solution")`
Using the `str()` function shows us that `schools` is saved as an integer variable.

::: panel-tabset
## R Code
```{r data-ans2.1, eval = FALSE}
str(education)
```

## Output
```{r data-ans2.2, echo = FALSE}
str(education)
```
:::
`r unhide()`
::::
:::

:::{.question}
::::{.question-header}
Task
::::
::::{.question-container .webex-check}
```{r, echo=FALSE}
opts <- c("`data.frame`", answer="`factor`", "`matrix`")
```

Complete the code to change the variables `year` and `level` in `education` to be factor variables.

::: panel-tabset
## R Code
::: {.webex-code}
`education$year <- ``r mcq(opts)``(x = ``r fitb(c("education$year", "education[, \"year\"]", "education[, 1]"))``,`
<ul style="margin-top: 0em; margin-left: 15em;">

`levels = ``r fitb(c("c(\"2016\", \"2017\", \"2018\", \"2019\", \"2020\", \"2021\", \"2022\")", "2016:2022", "c(2016, 2017, 2018, 2019, 2020, 2021, 2022)"), width=15)``)`
</ul>

<p>
</p>

`education$level <- ``r mcq(opts)``(x = ``r fitb(c("education$level", "education[, \"level\"]", "education[, 2]"))``,`
<ul style="margin-top: 0em; margin-left: 15em;">

`levels = c(``r fitb("\"ELC\", \"Primary\", \"Secondary\"", width=15)``))`
</ul>
:::
:::

`r hide("Solution")`

::: panel-tabset
## R Code
```{r data-ans3}
education$year <- factor(x = education$year,
                         levels = 2016:2022)

education$level <- factor(x = education$level,
                          levels = c("ELC", "Primary", "Secondary"))
```
:::
`r unhide()`
::::
:::

---

Refer to [Section 1.11 Working with Data](https://read.kortext.com/reader/pdf/92741/47){target="_blank"} of *Probability and Statistics with R* to learn more about checking the setup of a data set.


## Dealing with `NA` values

Data sets will often have missing values for a variety of different reasons; maybe because of human error, maybe because information was not disclosed or maybe because of a failed experiment for example. When data is correctly read into R these unknown values will be denoted by `NA`. In order to conduct analysis or perform calculations on your data, you may wish to remove these missing values from your data set. **Always think about whether this is an appropriate thing to do.**

One way in which we can remove missing values from a data set is to use the function `na.omit()`. This will return the data frame with any 'incomplete cases' removed. That is, any rows that have `NA` as the value for any variable will be removed from the data frame.

Looking at `chol`, we can see that there are missing values in rows 3, 7 and 9.

::: panel-tabset
## R Code
```{r chol1.1, eval = FALSE}
chol
```

## Output
```{r chol1.2, echo = FALSE}
cbind(" " = as.character(1:13), chol)
```
:::

If we run the following code, then these rows are removed from the data frame and we are left with only the 'complete cases'.

::: panel-tabset
## R Code
```{r data4.1, eval = FALSE}
na.omit(chol)
```

## Output
```{r data4.2, echo = FALSE}
na.omit(chol)
```
:::

Note that `na.omit()` preserves the original row labels. This means that there are no rows labelled 3, 7 or 9 in the resulting data frame because they have been completely removed.

`complete.cases()` is another useful function that can be used to remove rows that have `NA` values. This returns a logical vector, the same length as the number of rows of the data frame, that indicates whether a row contains any `NA` values (`FALSE`), or whether it is 'complete' (`TRUE`).

::: panel-tabset
## R Code
```{r data5.1, eval = FALSE}
complete.cases(chol)
```

## Output
```{r data5.2, echo = FALSE}
complete.cases(chol)
```
:::

Again we can see that the rows with missing values in `chol` are rows 3, 7 and 9 (since the third, seventh and ninth values in the output above are all `FALSE`). We can then use this logical vector to extract the rows which are complete from `chol`.

::: panel-tabset
## R Code
```{r data6.1, eval = FALSE}
chol[complete.cases(chol), ]
```

## Output
```{r data6.2, echo = FALSE}
chol[complete.cases(chol), ]
```
:::

Here, using `na.omit()` and `complete.cases()` have returned the same output.

:::{.question}
::::{.question-header}
Task
::::
::::{.question-container .webex-check}
```{r data-ans4, echo=FALSE}
opts2 <- c("none", "8 only", "8 and 15", answer="8 and 16", "16 only")
```

Which rows in `education` have missing values?
`r mcq(opts2)`

`r hide("Solution")`
Using `complete.cases()` shows us that rows 8 and 16 of `education` are incomplete and therefore contain `NA` values.

::: panel-tabset
## R Code
```{r data-ans5.1, eval = FALSE}
complete.cases(education)
```

## Output
```{r data-ans5.2, echo = FALSE}
complete.cases(education)
```
:::
`r unhide()`
::::
:::

:::{.question}
::::{.question-header}
Task
::::
::::{.question-container .webex-check}
Write code to remove all rows in `education` which contain `NA` values.

::: panel-tabset
## R Code
::: {.webex-code}
`r fitb(c("education[complete.cases(education), ]", "na.omit(education)", "education[!is.na(education$teachers), ]"))`
:::
:::

`r hide("Solution")`
Incomplete observations can be removed from `education` using any of the following lines of code.

::: panel-tabset
## R Code
```{r data-ans6, eval=FALSE}
na.omit(education)
education[complete.cases(education), ]
education[!is.na(education$teachers), ]
```
:::
`r unhide()`

::::
:::

In the case where we only want to know which entries of a vector or specific variable in a data frame are `NA`, we can use the function `is.na()`. For example, if missing values in the `trig` variable were not of concern but we wanted to identify missing values in the `smoke` column, we could use the following code.

::: panel-tabset
## R Code
```{r data7.1, eval = FALSE}
is.na(chol$smoke)
```

## Output
```{r data7.2, echo = FALSE}
is.na(chol$smoke)
```
:::

We can see that only the third row has the value `NA` for `smoke`, since the third element in the output from `is.na()` above is `TRUE`. In order to remove the row where `smoke` has a missing value, we can use the following code to index the `chol` data frame.

::: panel-tabset
## R Code
```{r data8.1, eval = FALSE}
chol[!is.na(chol$smoke), ]
```

## Output
```{r data8.2, echo = FALSE}
chol[!is.na(chol$smoke), ]
```
:::

Note that we use `!` in front of `is.na()` so that the logical vector returned has the value `TRUE` when values are complete and `FALSE` when values are missing i.e. `NA`.

---

You can look at further examples of dealing with missing data in [Section 1.11.1 Dealing with `NA` Values](https://read.kortext.com/reader/pdf/92741/51){target="_blank"} of *Probability and Statistics with R*.


## Sorting data frames

When investigating your data sets, you may want to order the values of a particular variable in increasing or decreasing order. This is easily done using the `sort()` function.

For example, we can view the ages of all subjects in `chol`, in increasing order, using the code below.

::: panel-tabset
## R Code
```{r data9.1, eval = FALSE}
sort(chol$age)
```

## Output
```{r data9.2, echo = FALSE}
sort(chol$age)
```
:::

Note that if we wanted to view these ages in decreasing order, we would add the argument `decreasing = TRUE` to the `sort()` function.

:::{.question}
::::{.question-header}
Task
::::
::::{.question-container .webex-check}
What is the largest value for `pupils` from the `education` data frame?
`r fitb(c("400312", "400,312"))`

`r hide("Solution")`
::: panel-tabset
## R Code
```{r data-ans7.1, eval = FALSE}
sort(education$pupils, decreasing = TRUE)[1]
```

## Output
```{r data-ans7.2, echo = FALSE}
sort(education$pupils, decreasing = TRUE)[1]
```
:::
`r unhide()`
::::
:::

The downside of using `sort()` is that we can only see the values from one variable of a data frame. If instead we wanted to order all subjects in `chol` from the youngest to the oldest and still see the values of all the other variables, we can use the function `order()`.

`order()` will return a vector showing which row has the smallest value, then the second smallest value and so on. For example, the following code shows us that the fourth subject in `chol` is the youngest and the thirteenth subject is the eldest.

::: panel-tabset
## R Code
```{r data10.1, eval = FALSE}
order(chol$age)
```

## Output
```{r data10.2, echo = FALSE}
order(chol$age)
```
:::

We can then use this vector to index the full data frame `chol` and see all the variables for each subject at once.

::: panel-tabset
## R Code
```{r data11.1, eval = FALSE}
chol[order(chol$age), ]
```

## Output
```{r data11.2, echo = FALSE}
chol[order(chol$age), ]
```
:::

In the output above, note that there are multiple subjects aged 32, 42 and 48. After ordering by `age`, R automatically shows these subjects with the same age in order of increasing row number. We could however add a second or third argument to `order()` to order the rows by another variable in the case where there are repeated values of the first variable.

For example, the following code orders all the subjects in `chol` by `age` first, and then for any subjects that are the same age, they will then be sorted in order of increasing `ldl`.

::: panel-tabset
## R Code
```{r data12.1, eval = FALSE}
chol[order(chol$age, chol$ldl), ]
```

## Output
```{r data12.2, echo = FALSE}
chol[order(chol$age, chol$ldl), ]
```
:::

:::{.question}
::::{.question-header}
Task
::::
::::{.question-container}
Write code to sort the observations from `education` in decreasing order of the number of pupils.

`r hide("Solution")`
We need to include the argument `decreasing = TRUE` within the function `order()` so that the observations are ordered from largest number of pupils to the smallest number of pupils. We can use the `order()` function within square brackets to show all variables in the data frame in order of decreasing number of pupils.

::: panel-tabset
## R Code
```{r data-ans8.1, eval = FALSE}
education[order(education$pupils, decreasing = TRUE), ]
```

## Output
```{r data-ans8.2, echo = FALSE}
education[order(education$pupils, decreasing = TRUE), ]
```
:::
`r unhide()`
::::
:::

---

Look at [Section 1.11.3 Sorting a Data Frame by One or More of Its Columns](https://read.kortext.com/reader/pdf/92741/55){target="_blank"} of *Probability and Statistics with R* to learn more about sorting and ordering data sets.


## Subsetting

When we want to only view particular elements of a data frame, this is known as subsetting the data. This is useful if you're dealing with extremely large data sets and only want to analyse female subjects, or subjects who are all from the same country for example. Subsetting the data means that you would extract only these subjects that you are actually interested in.

A useful function for extracting elements of a data frame is the function `subset()` (which we first saw in [Lab 1](https://moodle.gla.ac.uk/pluginfile.php/9072880/mod_resource/content/5/01-vectors.html#filter){target="_blank"}). This allows us to extract the elements of a data frame which meet particular conditions. The arguments that `subset()` takes are:

* `x =`: this is the data frame that we want to extract particular elements from.
* `subset =`: this is a logical statement which determines the elements to keep in the subsetted data frame.
* `select =`: this shows the column or columns from the data frame which the logical statement should be applied to.

For example, if we wanted to view the subjects in `chol` who have an LDL of greater than 170, then we can use the following code.

::: panel-tabset
## R Code
```{r data13.1, eval = FALSE}
subset(x = chol, subset = ldl > 170, select = ldl)
```

## Output
```{r data13.2, echo = FALSE}
subset(x = chol, subset = ldl > 170, select = ldl)
```
:::

This shows us that there are three patients with LDL greater than 170 (`subset = ldl > 170`) and we can also see the values of LDL for these patients (`select = ldl`).

If we wanted to see the values of the other variables in the data frame for only those patients with LDL greater than 170, then we can simply leave out the `select =` argument.

::: panel-tabset
## R Code
```{r data14.1, eval = FALSE}
subset(x = chol, subset = ldl > 170)
```

## Output
```{r data14.2, echo = FALSE}
subset(x = chol, subset = ldl > 170)
```
:::

Note that it is also possible to subset a data frame using logical statements within square brackets, `[ ]`. We could return the same output as above by indexing the `chol` using the following code.

::: panel-tabset
## R Code
```{r data15.1, eval = FALSE}
chol[chol$ldl > 170, ]
```

## Output
```{r data15.2, echo = FALSE}
chol[chol$ldl > 170, ]
```
:::

:::{.question}
::::{.question-header}
Task
::::
::::{.question-container}
Write some code to subset `education` to show the number of schools that have a collective total of more than 310,000 pupils in the years 2020, 2021 or 2022.

`r hide("Solution")`
The data frame that we want to subset is `education`, so this is what we'll feed in to the argument `x =`.

Since the question asks us to look for a collective total of more than 310,000 pupils, this means we want to only see the rows where the value for `pupils` is greater than 310,000. We also only want to see rows from the years 2020, 2021 or 2022. Because `year` is a factor, we need to specify each level that we are interested in. This means that we are looking for rows in which `pupils > 310000` AND `year == "2020"` or `year == "2021"` or `year == "2021"`. This is quite a lengthy logical statement in the following code.

The question also asks us to only show the number of schools for which these statements are true i.e. the column `schools`. To do this, we simply feed this variable to the `select =` argument.

::: panel-tabset
## R Code
```{r data-ans9.1, eval=FALSE}
subset(x = education,
       subset = pupils > 310000 & year == "2020" | 
         pupils > 310000 & year == "2021" | 
         pupils > 310000 & year == "2022",
       select = schools)
```
:::

A way we can shorten the logical statement in the `subset =` argument is to use the operator `%in%`. This will search for values in a vector and return the rows in which any of these values appear.

::: panel-tabset
## R Code
```{r data-ans9.2.1, eval = FALSE}
subset(x = education,
       subset = pupils > 310000 & year %in% c("2020", "2021", "2022"),
       select = schools)
```

## Output
```{r data-ans9.2.2, echo = FALSE}
subset(x = education,
       subset = pupils > 310000 & year %in% c("2020", "2021", "2022"),
       select = schools)
```
:::
`r unhide()`
::::
:::

---

You can read more about subsetting data frames in [Section 1.12 Using Logical Operators with Data Frames](https://read.kortext.com/reader/pdf/92741/58){target="_blank"} in *Probability and Statistics with R*.


## Summarising data

Data sets will often contain a lot of information which is not easy to interpret at a glance. It is therefore useful to be able to summarise the data they contain, in appropriate ways for each different type of variable.

One of the simplest functions to help summarise a data frame is the `summary()` function.

::: panel-tabset
## R Code
```{r data16.1, eval = FALSE}
summary(chol)
```

## Output
```{r data16.2, echo = FALSE}
summary(chol)
```
:::

The output from `summary()` shows information for each column in the data frame you provide as the argument. For numerical variables, we are shown summary statistics such as the minimum value, the mean or the 3rd quartile. For factor variables, we are shown how many observations there are in each level of the factor. If there are any `NA` values in a column, the total number of these will also be shown for each variable.

When a data frame contains categorical variables, a neater way to summarise the counts of the different levels is in contingency tables. These show counts of how many times each level of a categorical variable appeared in the data frame. The function to create contingency tables in R is `table()`. The only argument that `table()` needs is the factor variable you want to summarise.

For example, we can quickly show counts of how many subjects in `chol` fall into each of the three levels of the `smoke` variable using the following code.

::: panel-tabset
## R Code
```{r data17.1, eval = FALSE}
table(chol$smoke)
```

## Output
```{r data17.2, echo = FALSE}
table(chol$smoke)
```
:::

If we wanted to further split these counts by the variable `gender`, then we simply add this as a second argument to the `table()` function.

::: panel-tabset
## R Code
```{r data18.1, eval = FALSE}
smoke_counts <- table(chol$smoke, chol$gender)
smoke_counts
```

## Output
```{r data18.2, echo = FALSE}
smoke_counts <- table(chol$smoke, chol$gender)
smoke_counts
```
:::

We can easily compute the sums of rows or columns in a table using the function `margin.table()`. Here we need to provide `margin.table()` with the following arguments:

* `x =`: this is the table you want to sum over.
* `margin =`: this tells R whether you want to sum over rows (set the value to 1), or columns (set the value to 2).

For example, we can use the table `smoke_counts`, created above, to count the number of female and male subjects for whom we know their smoking status, using `margin.table()`.

::: panel-tabset
## R Code
```{r data19.1, eval = FALSE}
margin.table(x = smoke_counts, margin = 2)
```

## Output
```{r data19.2, echo = FALSE}
margin.table(x = smoke_counts, margin = 2)
```
:::

Another useful function to use with tables is `prop.table()`. This takes the same arguments as `margin.table()` but shows row or column proportions, rather than sums.

For example, to calculate the proportions of current smokers, ex-smokers and non-smokers that are female and male, we can use the following code.

::: panel-tabset
## R Code
```{r data20.1, eval = FALSE}
prop.table(x = smoke_counts, margin = 1)
```

## Output
```{r data20.2, echo = FALSE}
prop.table(x = smoke_counts, margin = 1)
```
:::

Suppose you wanted to calculate summary statistics for one variable in a data frame, but have it split by the levels of a different categorical variable.

The function in R which calculates a summary statistic for one numeric variable, split by the levels of a factor is `tapply()`. The arguments that `tapply()` can take are as follows:

* `X =`: this is the numeric variable that you want to apply the function calculating some summary statistic to.
* `INDEX =`: this is a **list** containing the categorical variable (or variables) you want to split the calculation of the summary statistic across.
* `FUN =`: this is the name of the function you want to apply to the numeric variable. Examples include `mean`, `median`, `max`, `min`, `mode`, `sd` etc.

In the case where we are interested in knowing the mean HDL for subjects who were current smokers, subjects who were ex-smokers and subjects who were non-smokers, we can use `tapply()`.

::: panel-tabset
## R Code
```{r data21.1, eval = FALSE}
tapply(X = chol$hdl, INDEX = list(chol$smoke), FUN = mean)
```

## Output
```{r data21.2, echo = FALSE}
tapply(X = chol$hdl, INDEX = list(chol$smoke), FUN = mean)
```
:::

We can see, for example, that the mean HDL for non-smokers is 61.17. <!--units?-->

The list provided to the `INDEX =` argument can contain more than one categorical variable. For example, we can calculate the mean HDL of females and males for each level of the `smoke` variable using the following code.

::: panel-tabset
## R Code
```{r data22.1, eval = FALSE}
tapply(X = chol$hdl, INDEX = list(chol$smoke, chol$gender), FUN = mean)
```

## Output
```{r data22.2, echo = FALSE}
tapply(X = chol$hdl, INDEX = list(chol$smoke, chol$gender), FUN = mean)
```
:::

Now we can see that the mean HDL for females who are non-smokers is 57.20. <!-- units--> The mean HDL for males who are ex-smokers is `NA` because there are no males included in `chol` who are ex-smokers.

:::{.question}
::::{.question-header}
Task
::::
::::{.question-container .webex-check}
What is the mean total number of teachers in primary schools across all years?
`r fitb(c("25055", "25056", "25055.5", "25055.50", "25055.500", "25055.5000"))`

`r hide("Solution")`
In order to find this value we want to use the function `tapply()`. `teachers` is the column we want to calculate the `mean` for, but make sure to split this by the different levels in the `level` column.

`teachers` contains some `NA` values, which when passed to the function `mean` will return another `NA` value unless you provide to `tapply()` the additional argument `na.rm = TRUE`. This tells R to ignore the `NA` values when calculating the mean and only use those rows which have a numerical value.

::: panel-tabset
## R Code
```{r data-ans10.1, eval = FALSE}
tapply(X = education$teachers, INDEX = list(education$level),
       FUN = mean, na.rm = TRUE)
```

## Output
```{r data-ans10.2, echo = FALSE}
tapply(X = education$teachers, INDEX = list(education$level),
       FUN = mean, na.rm = TRUE)
```
:::
`r unhide()`
::::
:::

---

To read more on creating tables and summarising data in R, see Sections [1.13 Tables](https://read.kortext.com/reader/pdf/92741/62){target="_blank"} and [1.14 Summarizing Functions](https://read.kortext.com/reader/pdf/92741/66){target="_blank"} in *Probability and Statistics with R*.


## Creating variables

In the case where we have another vector or data frame that we wish to join to an existing one, we can do this using one of the functions `cbind()` or `rbind()`.

* `cbind()` combines the vectors or data frames together by making additional columns, whereas 

* `rbind()` combines them by adding the new vector or data frame as additional rows.

Let's see an example to understand how this works. The file *measurements.csv* contains information on the heights and weights of all 13 patients in the original `chol` data frame. We can begin by reading it in to the **Environment** tab using the following code.

::: panel-tabset
## R Code
```{r read-measurements, echo=FALSE}
measurements <- read.csv(file = "Data/measurements.csv", fileEncoding = 'UTF-8-BOM')
```

```{r data23, eval=FALSE}
measurements <- read.csv(file = "measurements.csv")
```
:::

We can then add `measurements` to `chol` as two additional columns and save the resulting data frame as `chol_full` using the code below.

::: panel-tabset
## R Code
```{r data24.1, eval = FALSE}
chol_full <- cbind(chol, measurements)
head(chol_full)
```

## Output
```{r data24.2, echo = FALSE}
chol_full <- cbind(chol, measurements)
head(chol_full)
```
:::

Another way to easily create a new variable in a data frame is to use the `$` operator. We can simply add the name of the data frame to the left of `$` and our new variable name to the right. Then we can set this variable to be any pre-existing vector, or calculate a new vector based on variables from the data frame.

For example, if we wanted to create a new variable, `bmi`, in `chol` which shows the BMI of each patient, then we can use the following code.

::: panel-tabset
## R Code
```{r data25.1, eval = FALSE}
chol_full$bmi <- chol_full$weight/(chol_full$height)^2
head(chol_full)
```

## Output
```{r data25.2, echo = FALSE}
chol_full$bmi <- chol_full$weight/(chol_full$height)^2
head(chol_full)
```
:::

:::{.question}
::::{.question-header}
Task
::::
::::{.question-container}
In the `education` data frame, create a new variable called `ratio` which calculates the pupil to teacher ratio in each level of education. That is,

$$\mbox{ratio}=\textstyle\frac{\mbox{puils}}{\mbox{teachers}}$$
`r hide("Solution")`
::: panel-tabset
## R Code
```{r data-ans11}
education$ratio <- education$pupils/education$teachers
```
:::
`r unhide()`
::::
:::

Now suppose that information on a fourteenth subject is known but has not been included in the original `chol` data frame. This data is shown in @tbl-subject-table below.

```{r subject-setup, echo=FALSE}
subject <- data.frame(id = "P461", ldl = 148, hdl = 78, trig = 120, age = 41, gender = "male", 
                      smoke = "current", weight = 84.05, height = 1.79)
subject <- as.matrix(subject)
```

```{r subject-table, echo=FALSE}
#| tbl-cap: "Cholesterol data for the fourteenth patient."
#| label: tbl-subject-table

kable(subject)
```

In this case we can add the new subject as an additional row using the `rbind()` function.

First, we need to create a data frame containing the information for this subject. In order for us to add this data frame as a row to `chol_full`, it needs to have the same number of variables. Therefore, we also need to calculate the BMI for this subject and call it `bmi`. We can do all this with the following code.

::: panel-tabset
## R Code
```{r data26}
subject <- data.frame(id = "P461", ldl = 148, hdl = 78, trig = 120, age = 41, 
                      gender = "male", smoke = "current", weight = 84.05,
                      height = 1.79)

subject$bmi <- subject$weight/(subject$height)^2
```
:::

Now we can add this subject to `chol_full` using the code below.

::: panel-tabset
## R Code
```{r data27.1, eval = FALSE}
chol_full <- rbind(chol_full, subject)
tail(chol_full)
```

## Output
```{r data27.2, echo = FALSE}
chol_full <- rbind(chol_full, subject)
tail(chol_full)
```
:::

Note that `tail()` is a function very similar to `head()`, but rather than showing the first 6 rows by default, it shows the last 6.

---

Sections [1.11.2 Creating New Variables in a Data Frame](https://read.kortext.com/reader/pdf/92741/54){target="_blank"} and [1.13 Tables](https://read.kortext.com/reader/pdf/92741/62){target="_blank"} of *Probability and Statistics with R* describe how to create new variables.

See @sec-cut to learn how to create a new variable in a data frame by breaking an exisiting variable into different levels.



