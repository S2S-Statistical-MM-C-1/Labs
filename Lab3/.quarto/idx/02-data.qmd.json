{"title":"Working With Data","markdown":{"yaml":{"title":"Working With Data"},"headingText":"Checking variable types","headingAttr":{"id":"sec-checking","classes":[],"keyvalue":[]},"containsRefs":false,"markdown":"\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo=TRUE, eval=TRUE, comment=NA)\nlibrary(webexercises)\nlibrary(PASWR2)\nlibrary(knitr)\nlibrary(kableExtra)\nlibrary(ggplot2)\nlibrary(tidyverse)\n```\n\n```{r read1, echo = FALSE}\nchol <- read.table(file = \"Data/chol.txt\", header = TRUE, fileEncoding = 'UTF-8-BOM')\neducation <- read.csv(file = \"Data/edu.csv\", na.strings = \"*\", fileEncoding = 'UTF-8-BOM')\n```\n\n\nOnce a data frame has been read into R, it is always a good idea to examine its contents using the `str()` function to see the **structure** of the data object. We have already seen the `str()` function in [Lab 2](https://moodle.gla.ac.uk/pluginfile.php/9073095/mod_resource/content/2/02-data.html#sec-df){target=\"_blank\"} but as a reminder, it shows us the type of vector each column in a data frame is saved as.\n\nRunning the following code tells us that the four variables `ldl`, `hdl`, `trig` and `age` are all integer vectors and that `id`, `gender` and `smoke` are character vectors.\n\n::: panel-tabset\n## R Code\n```{r data1.1, eval = FALSE}\nstr(chol)\n```\n\n## Output\n```{r data1.2, echo = FALSE}\nstr(chol)\n```\n:::\n\nBecause `gender` only takes the values `\"female\"` or `\"male\"` in this case, and `smoke` is categorised into three levels, `\"no\"`, `\"ex-smoker\"` and `\"current\"`, it makes sense to treat both these variables as factors instead of character vectors.\n\nWe can use what we learned in [Lab 2](https://moodle.gla.ac.uk/pluginfile.php/9073095/mod_resource/content/2/02-data.html#sec-fact){target=\"_blank\"} to change these variables into factors. \n\n::: panel-tabset\n## R Code\n```{r data2}\nchol$gender <- factor(x = chol$gender, levels = c(\"female\", \"male\"))\nchol$smoke <- factor(x = chol$smoke, levels = c(\"no\", \"ex-smoker\", \"current\"))\n```\n:::\n\nNow using `str()` to check the type of vector each column is saved as shows us that `gender` and `smoke` are both now factors.\n\n::: panel-tabset\n## R Code\n```{r data3.1, eval = FALSE}\nstr(chol)\n```\n\n## Output\n```{r data3.2, echo = FALSE}\nstr(chol)\n```\n:::\n\n:::{.question}\n::::{.question-header}\nTask\n::::\n::::{.question-container .webex-check}\n```{r data-ans1, echo=FALSE}\nopts1 <- c(\"character\", \"logical\", \"numeric\", answer=\"integer\", \"factor\")\n```\nWhat type of variable is `schools` saved as in the `education` data frame?\n`r mcq(opts1)`\n\n`r hide(\"Solution\")`\nUsing the `str()` function shows us that `schools` is saved as an integer variable.\n\n::: panel-tabset\n## R Code\n```{r data-ans2.1, eval = FALSE}\nstr(education)\n```\n\n## Output\n```{r data-ans2.2, echo = FALSE}\nstr(education)\n```\n:::\n`r unhide()`\n::::\n:::\n\n:::{.question}\n::::{.question-header}\nTask\n::::\n::::{.question-container .webex-check}\n```{r, echo=FALSE}\nopts <- c(\"`data.frame`\", answer=\"`factor`\", \"`matrix`\")\n```\n\nComplete the code to change the variables `year` and `level` in `education` to be factor variables.\n\n::: panel-tabset\n## R Code\n::: {.webex-code}\n`education$year <- ``r mcq(opts)``(x = ``r fitb(c(\"education$year\", \"education[, \\\"year\\\"]\", \"education[, 1]\"))``,`\n<ul style=\"margin-top: 0em; margin-left: 15em;\">\n\n`levels = ``r fitb(c(\"c(\\\"2016\\\", \\\"2017\\\", \\\"2018\\\", \\\"2019\\\", \\\"2020\\\", \\\"2021\\\", \\\"2022\\\")\", \"2016:2022\", \"c(2016, 2017, 2018, 2019, 2020, 2021, 2022)\"), width=15)``)`\n</ul>\n\n<p>\n</p>\n\n`education$level <- ``r mcq(opts)``(x = ``r fitb(c(\"education$level\", \"education[, \\\"level\\\"]\", \"education[, 2]\"))``,`\n<ul style=\"margin-top: 0em; margin-left: 15em;\">\n\n`levels = c(``r fitb(\"\\\"ELC\\\", \\\"Primary\\\", \\\"Secondary\\\"\", width=15)``))`\n</ul>\n:::\n:::\n\n`r hide(\"Solution\")`\n\n::: panel-tabset\n## R Code\n```{r data-ans3}\neducation$year <- factor(x = education$year,\n                         levels = 2016:2022)\n\neducation$level <- factor(x = education$level,\n                          levels = c(\"ELC\", \"Primary\", \"Secondary\"))\n```\n:::\n`r unhide()`\n::::\n:::\n\n---\n\nRefer to [Section 1.11 Working with Data](https://read.kortext.com/reader/pdf/92741/47){target=\"_blank\"} of *Probability and Statistics with R* to learn more about checking the setup of a data set.\n\n\n## Dealing with `NA` values\n\nData sets will often have missing values for a variety of different reasons; maybe because of human error, maybe because information was not disclosed or maybe because of a failed experiment for example. When data is correctly read into R these unknown values will be denoted by `NA`. In order to conduct analysis or perform calculations on your data, you may wish to remove these missing values from your data set. **Always think about whether this is an appropriate thing to do.**\n\nOne way in which we can remove missing values from a data set is to use the function `na.omit()`. This will return the data frame with any 'incomplete cases' removed. That is, any rows that have `NA` as the value for any variable will be removed from the data frame.\n\nLooking at `chol`, we can see that there are missing values in rows 3, 7 and 9.\n\n::: panel-tabset\n## R Code\n```{r chol1.1, eval = FALSE}\nchol\n```\n\n## Output\n```{r chol1.2, echo = FALSE}\ncbind(\" \" = as.character(1:13), chol)\n```\n:::\n\nIf we run the following code, then these rows are removed from the data frame and we are left with only the 'complete cases'.\n\n::: panel-tabset\n## R Code\n```{r data4.1, eval = FALSE}\nna.omit(chol)\n```\n\n## Output\n```{r data4.2, echo = FALSE}\nna.omit(chol)\n```\n:::\n\nNote that `na.omit()` preserves the original row labels. This means that there are no rows labelled 3, 7 or 9 in the resulting data frame because they have been completely removed.\n\n`complete.cases()` is another useful function that can be used to remove rows that have `NA` values. This returns a logical vector, the same length as the number of rows of the data frame, that indicates whether a row contains any `NA` values (`FALSE`), or whether it is 'complete' (`TRUE`).\n\n::: panel-tabset\n## R Code\n```{r data5.1, eval = FALSE}\ncomplete.cases(chol)\n```\n\n## Output\n```{r data5.2, echo = FALSE}\ncomplete.cases(chol)\n```\n:::\n\nAgain we can see that the rows with missing values in `chol` are rows 3, 7 and 9 (since the third, seventh and ninth values in the output above are all `FALSE`). We can then use this logical vector to extract the rows which are complete from `chol`.\n\n::: panel-tabset\n## R Code\n```{r data6.1, eval = FALSE}\nchol[complete.cases(chol), ]\n```\n\n## Output\n```{r data6.2, echo = FALSE}\nchol[complete.cases(chol), ]\n```\n:::\n\nHere, using `na.omit()` and `complete.cases()` have returned the same output.\n\n:::{.question}\n::::{.question-header}\nTask\n::::\n::::{.question-container .webex-check}\n```{r data-ans4, echo=FALSE}\nopts2 <- c(\"none\", \"8 only\", \"8 and 15\", answer=\"8 and 16\", \"16 only\")\n```\n\nWhich rows in `education` have missing values?\n`r mcq(opts2)`\n\n`r hide(\"Solution\")`\nUsing `complete.cases()` shows us that rows 8 and 16 of `education` are incomplete and therefore contain `NA` values.\n\n::: panel-tabset\n## R Code\n```{r data-ans5.1, eval = FALSE}\ncomplete.cases(education)\n```\n\n## Output\n```{r data-ans5.2, echo = FALSE}\ncomplete.cases(education)\n```\n:::\n`r unhide()`\n::::\n:::\n\n:::{.question}\n::::{.question-header}\nTask\n::::\n::::{.question-container .webex-check}\nWrite code to remove all rows in `education` which contain `NA` values.\n\n::: panel-tabset\n## R Code\n::: {.webex-code}\n`r fitb(c(\"education[complete.cases(education), ]\", \"na.omit(education)\", \"education[!is.na(education$teachers), ]\"))`\n:::\n:::\n\n`r hide(\"Solution\")`\nIncomplete observations can be removed from `education` using any of the following lines of code.\n\n::: panel-tabset\n## R Code\n```{r data-ans6, eval=FALSE}\nna.omit(education)\neducation[complete.cases(education), ]\neducation[!is.na(education$teachers), ]\n```\n:::\n`r unhide()`\n\n::::\n:::\n\nIn the case where we only want to know which entries of a vector or specific variable in a data frame are `NA`, we can use the function `is.na()`. For example, if missing values in the `trig` variable were not of concern but we wanted to identify missing values in the `smoke` column, we could use the following code.\n\n::: panel-tabset\n## R Code\n```{r data7.1, eval = FALSE}\nis.na(chol$smoke)\n```\n\n## Output\n```{r data7.2, echo = FALSE}\nis.na(chol$smoke)\n```\n:::\n\nWe can see that only the third row has the value `NA` for `smoke`, since the third element in the output from `is.na()` above is `TRUE`. In order to remove the row where `smoke` has a missing value, we can use the following code to index the `chol` data frame.\n\n::: panel-tabset\n## R Code\n```{r data8.1, eval = FALSE}\nchol[!is.na(chol$smoke), ]\n```\n\n## Output\n```{r data8.2, echo = FALSE}\nchol[!is.na(chol$smoke), ]\n```\n:::\n\nNote that we use `!` in front of `is.na()` so that the logical vector returned has the value `TRUE` when values are complete and `FALSE` when values are missing i.e. `NA`.\n\n---\n\nYou can look at further examples of dealing with missing data in [Section 1.11.1 Dealing with `NA` Values](https://read.kortext.com/reader/pdf/92741/51){target=\"_blank\"} of *Probability and Statistics with R*.\n\n\n## Sorting data frames\n\nWhen investigating your data sets, you may want to order the values of a particular variable in increasing or decreasing order. This is easily done using the `sort()` function.\n\nFor example, we can view the ages of all subjects in `chol`, in increasing order, using the code below.\n\n::: panel-tabset\n## R Code\n```{r data9.1, eval = FALSE}\nsort(chol$age)\n```\n\n## Output\n```{r data9.2, echo = FALSE}\nsort(chol$age)\n```\n:::\n\nNote that if we wanted to view these ages in decreasing order, we would add the argument `decreasing = TRUE` to the `sort()` function.\n\n:::{.question}\n::::{.question-header}\nTask\n::::\n::::{.question-container .webex-check}\nWhat is the largest value for `pupils` from the `education` data frame?\n`r fitb(c(\"400312\", \"400,312\"))`\n\n`r hide(\"Solution\")`\n::: panel-tabset\n## R Code\n```{r data-ans7.1, eval = FALSE}\nsort(education$pupils, decreasing = TRUE)[1]\n```\n\n## Output\n```{r data-ans7.2, echo = FALSE}\nsort(education$pupils, decreasing = TRUE)[1]\n```\n:::\n`r unhide()`\n::::\n:::\n\nThe downside of using `sort()` is that we can only see the values from one variable of a data frame. If instead we wanted to order all subjects in `chol` from the youngest to the oldest and still see the values of all the other variables, we can use the function `order()`.\n\n`order()` will return a vector showing which row has the smallest value, then the second smallest value and so on. For example, the following code shows us that the fourth subject in `chol` is the youngest and the thirteenth subject is the eldest.\n\n::: panel-tabset\n## R Code\n```{r data10.1, eval = FALSE}\norder(chol$age)\n```\n\n## Output\n```{r data10.2, echo = FALSE}\norder(chol$age)\n```\n:::\n\nWe can then use this vector to index the full data frame `chol` and see all the variables for each subject at once.\n\n::: panel-tabset\n## R Code\n```{r data11.1, eval = FALSE}\nchol[order(chol$age), ]\n```\n\n## Output\n```{r data11.2, echo = FALSE}\nchol[order(chol$age), ]\n```\n:::\n\nIn the output above, note that there are multiple subjects aged 32, 42 and 48. After ordering by `age`, R automatically shows these subjects with the same age in order of increasing row number. We could however add a second or third argument to `order()` to order the rows by another variable in the case where there are repeated values of the first variable.\n\nFor example, the following code orders all the subjects in `chol` by `age` first, and then for any subjects that are the same age, they will then be sorted in order of increasing `ldl`.\n\n::: panel-tabset\n## R Code\n```{r data12.1, eval = FALSE}\nchol[order(chol$age, chol$ldl), ]\n```\n\n## Output\n```{r data12.2, echo = FALSE}\nchol[order(chol$age, chol$ldl), ]\n```\n:::\n\n:::{.question}\n::::{.question-header}\nTask\n::::\n::::{.question-container}\nWrite code to sort the observations from `education` in decreasing order of the number of pupils.\n\n`r hide(\"Solution\")`\nWe need to include the argument `decreasing = TRUE` within the function `order()` so that the observations are ordered from largest number of pupils to the smallest number of pupils. We can use the `order()` function within square brackets to show all variables in the data frame in order of decreasing number of pupils.\n\n::: panel-tabset\n## R Code\n```{r data-ans8.1, eval = FALSE}\neducation[order(education$pupils, decreasing = TRUE), ]\n```\n\n## Output\n```{r data-ans8.2, echo = FALSE}\neducation[order(education$pupils, decreasing = TRUE), ]\n```\n:::\n`r unhide()`\n::::\n:::\n\n---\n\nLook at [Section 1.11.3 Sorting a Data Frame by One or More of Its Columns](https://read.kortext.com/reader/pdf/92741/55){target=\"_blank\"} of *Probability and Statistics with R* to learn more about sorting and ordering data sets.\n\n\n## Subsetting\n\nWhen we want to only view particular elements of a data frame, this is known as subsetting the data. This is useful if you're dealing with extremely large data sets and only want to analyse female subjects, or subjects who are all from the same country for example. Subsetting the data means that you would extract only these subjects that you are actually interested in.\n\nA useful function for extracting elements of a data frame is the function `subset()` (which we first saw in [Lab 1](https://moodle.gla.ac.uk/pluginfile.php/9072880/mod_resource/content/5/01-vectors.html#filter){target=\"_blank\"}). This allows us to extract the elements of a data frame which meet particular conditions. The arguments that `subset()` takes are:\n\n* `x =`: this is the data frame that we want to extract particular elements from.\n* `subset =`: this is a logical statement which determines the elements to keep in the subsetted data frame.\n* `select =`: this shows the column or columns from the data frame which the logical statement should be applied to.\n\nFor example, if we wanted to view the subjects in `chol` who have an LDL of greater than 170, then we can use the following code.\n\n::: panel-tabset\n## R Code\n```{r data13.1, eval = FALSE}\nsubset(x = chol, subset = ldl > 170, select = ldl)\n```\n\n## Output\n```{r data13.2, echo = FALSE}\nsubset(x = chol, subset = ldl > 170, select = ldl)\n```\n:::\n\nThis shows us that there are three patients with LDL greater than 170 (`subset = ldl > 170`) and we can also see the values of LDL for these patients (`select = ldl`).\n\nIf we wanted to see the values of the other variables in the data frame for only those patients with LDL greater than 170, then we can simply leave out the `select =` argument.\n\n::: panel-tabset\n## R Code\n```{r data14.1, eval = FALSE}\nsubset(x = chol, subset = ldl > 170)\n```\n\n## Output\n```{r data14.2, echo = FALSE}\nsubset(x = chol, subset = ldl > 170)\n```\n:::\n\nNote that it is also possible to subset a data frame using logical statements within square brackets, `[ ]`. We could return the same output as above by indexing the `chol` using the following code.\n\n::: panel-tabset\n## R Code\n```{r data15.1, eval = FALSE}\nchol[chol$ldl > 170, ]\n```\n\n## Output\n```{r data15.2, echo = FALSE}\nchol[chol$ldl > 170, ]\n```\n:::\n\n:::{.question}\n::::{.question-header}\nTask\n::::\n::::{.question-container}\nWrite some code to subset `education` to show the number of schools that have a collective total of more than 310,000 pupils in the years 2020, 2021 or 2022.\n\n`r hide(\"Solution\")`\nThe data frame that we want to subset is `education`, so this is what we'll feed in to the argument `x =`.\n\nSince the question asks us to look for a collective total of more than 310,000 pupils, this means we want to only see the rows where the value for `pupils` is greater than 310,000. We also only want to see rows from the years 2020, 2021 or 2022. Because `year` is a factor, we need to specify each level that we are interested in. This means that we are looking for rows in which `pupils > 310000` AND `year == \"2020\"` or `year == \"2021\"` or `year == \"2021\"`. This is quite a lengthy logical statement in the following code.\n\nThe question also asks us to only show the number of schools for which these statements are true i.e. the column `schools`. To do this, we simply feed this variable to the `select =` argument.\n\n::: panel-tabset\n## R Code\n```{r data-ans9.1, eval=FALSE}\nsubset(x = education,\n       subset = pupils > 310000 & year == \"2020\" | \n         pupils > 310000 & year == \"2021\" | \n         pupils > 310000 & year == \"2022\",\n       select = schools)\n```\n:::\n\nA way we can shorten the logical statement in the `subset =` argument is to use the operator `%in%`. This will search for values in a vector and return the rows in which any of these values appear.\n\n::: panel-tabset\n## R Code\n```{r data-ans9.2.1, eval = FALSE}\nsubset(x = education,\n       subset = pupils > 310000 & year %in% c(\"2020\", \"2021\", \"2022\"),\n       select = schools)\n```\n\n## Output\n```{r data-ans9.2.2, echo = FALSE}\nsubset(x = education,\n       subset = pupils > 310000 & year %in% c(\"2020\", \"2021\", \"2022\"),\n       select = schools)\n```\n:::\n`r unhide()`\n::::\n:::\n\n---\n\nYou can read more about subsetting data frames in [Section 1.12 Using Logical Operators with Data Frames](https://read.kortext.com/reader/pdf/92741/58){target=\"_blank\"} in *Probability and Statistics with R*.\n\n\n## Summarising data\n\nData sets will often contain a lot of information which is not easy to interpret at a glance. It is therefore useful to be able to summarise the data they contain, in appropriate ways for each different type of variable.\n\nOne of the simplest functions to help summarise a data frame is the `summary()` function.\n\n::: panel-tabset\n## R Code\n```{r data16.1, eval = FALSE}\nsummary(chol)\n```\n\n## Output\n```{r data16.2, echo = FALSE}\nsummary(chol)\n```\n:::\n\nThe output from `summary()` shows information for each column in the data frame you provide as the argument. For numerical variables, we are shown summary statistics such as the minimum value, the mean or the 3rd quartile. For factor variables, we are shown how many observations there are in each level of the factor. If there are any `NA` values in a column, the total number of these will also be shown for each variable.\n\nWhen a data frame contains categorical variables, a neater way to summarise the counts of the different levels is in contingency tables. These show counts of how many times each level of a categorical variable appeared in the data frame. The function to create contingency tables in R is `table()`. The only argument that `table()` needs is the factor variable you want to summarise.\n\nFor example, we can quickly show counts of how many subjects in `chol` fall into each of the three levels of the `smoke` variable using the following code.\n\n::: panel-tabset\n## R Code\n```{r data17.1, eval = FALSE}\ntable(chol$smoke)\n```\n\n## Output\n```{r data17.2, echo = FALSE}\ntable(chol$smoke)\n```\n:::\n\nIf we wanted to further split these counts by the variable `gender`, then we simply add this as a second argument to the `table()` function.\n\n::: panel-tabset\n## R Code\n```{r data18.1, eval = FALSE}\nsmoke_counts <- table(chol$smoke, chol$gender)\nsmoke_counts\n```\n\n## Output\n```{r data18.2, echo = FALSE}\nsmoke_counts <- table(chol$smoke, chol$gender)\nsmoke_counts\n```\n:::\n\nWe can easily compute the sums of rows or columns in a table using the function `margin.table()`. Here we need to provide `margin.table()` with the following arguments:\n\n* `x =`: this is the table you want to sum over.\n* `margin =`: this tells R whether you want to sum over rows (set the value to 1), or columns (set the value to 2).\n\nFor example, we can use the table `smoke_counts`, created above, to count the number of female and male subjects for whom we know their smoking status, using `margin.table()`.\n\n::: panel-tabset\n## R Code\n```{r data19.1, eval = FALSE}\nmargin.table(x = smoke_counts, margin = 2)\n```\n\n## Output\n```{r data19.2, echo = FALSE}\nmargin.table(x = smoke_counts, margin = 2)\n```\n:::\n\nAnother useful function to use with tables is `prop.table()`. This takes the same arguments as `margin.table()` but shows row or column proportions, rather than sums.\n\nFor example, to calculate the proportions of current smokers, ex-smokers and non-smokers that are female and male, we can use the following code.\n\n::: panel-tabset\n## R Code\n```{r data20.1, eval = FALSE}\nprop.table(x = smoke_counts, margin = 1)\n```\n\n## Output\n```{r data20.2, echo = FALSE}\nprop.table(x = smoke_counts, margin = 1)\n```\n:::\n\nSuppose you wanted to calculate summary statistics for one variable in a data frame, but have it split by the levels of a different categorical variable.\n\nThe function in R which calculates a summary statistic for one numeric variable, split by the levels of a factor is `tapply()`. The arguments that `tapply()` can take are as follows:\n\n* `X =`: this is the numeric variable that you want to apply the function calculating some summary statistic to.\n* `INDEX =`: this is a **list** containing the categorical variable (or variables) you want to split the calculation of the summary statistic across.\n* `FUN =`: this is the name of the function you want to apply to the numeric variable. Examples include `mean`, `median`, `max`, `min`, `mode`, `sd` etc.\n\nIn the case where we are interested in knowing the mean HDL for subjects who were current smokers, subjects who were ex-smokers and subjects who were non-smokers, we can use `tapply()`.\n\n::: panel-tabset\n## R Code\n```{r data21.1, eval = FALSE}\ntapply(X = chol$hdl, INDEX = list(chol$smoke), FUN = mean)\n```\n\n## Output\n```{r data21.2, echo = FALSE}\ntapply(X = chol$hdl, INDEX = list(chol$smoke), FUN = mean)\n```\n:::\n\nWe can see, for example, that the mean HDL for non-smokers is 61.17. <!--units?-->\n\nThe list provided to the `INDEX =` argument can contain more than one categorical variable. For example, we can calculate the mean HDL of females and males for each level of the `smoke` variable using the following code.\n\n::: panel-tabset\n## R Code\n```{r data22.1, eval = FALSE}\ntapply(X = chol$hdl, INDEX = list(chol$smoke, chol$gender), FUN = mean)\n```\n\n## Output\n```{r data22.2, echo = FALSE}\ntapply(X = chol$hdl, INDEX = list(chol$smoke, chol$gender), FUN = mean)\n```\n:::\n\nNow we can see that the mean HDL for females who are non-smokers is 57.20. <!-- units--> The mean HDL for males who are ex-smokers is `NA` because there are no males included in `chol` who are ex-smokers.\n\n:::{.question}\n::::{.question-header}\nTask\n::::\n::::{.question-container .webex-check}\nWhat is the mean total number of teachers in primary schools across all years?\n`r fitb(c(\"25055\", \"25056\", \"25055.5\", \"25055.50\", \"25055.500\", \"25055.5000\"))`\n\n`r hide(\"Solution\")`\nIn order to find this value we want to use the function `tapply()`. `teachers` is the column we want to calculate the `mean` for, but make sure to split this by the different levels in the `level` column.\n\n`teachers` contains some `NA` values, which when passed to the function `mean` will return another `NA` value unless you provide to `tapply()` the additional argument `na.rm = TRUE`. This tells R to ignore the `NA` values when calculating the mean and only use those rows which have a numerical value.\n\n::: panel-tabset\n## R Code\n```{r data-ans10.1, eval = FALSE}\ntapply(X = education$teachers, INDEX = list(education$level),\n       FUN = mean, na.rm = TRUE)\n```\n\n## Output\n```{r data-ans10.2, echo = FALSE}\ntapply(X = education$teachers, INDEX = list(education$level),\n       FUN = mean, na.rm = TRUE)\n```\n:::\n`r unhide()`\n::::\n:::\n\n---\n\nTo read more on creating tables and summarising data in R, see Sections [1.13 Tables](https://read.kortext.com/reader/pdf/92741/62){target=\"_blank\"} and [1.14 Summarizing Functions](https://read.kortext.com/reader/pdf/92741/66){target=\"_blank\"} in *Probability and Statistics with R*.\n\n\n## Creating variables\n\nIn the case where we have another vector or data frame that we wish to join to an existing one, we can do this using one of the functions `cbind()` or `rbind()`.\n\n* `cbind()` combines the vectors or data frames together by making additional columns, whereas \n\n* `rbind()` combines them by adding the new vector or data frame as additional rows.\n\nLet's see an example to understand how this works. The file *measurements.csv* contains information on the heights and weights of all 13 patients in the original `chol` data frame. We can begin by reading it in to the **Environment** tab using the following code.\n\n::: panel-tabset\n## R Code\n```{r read-measurements, echo=FALSE}\nmeasurements <- read.csv(file = \"Data/measurements.csv\", fileEncoding = 'UTF-8-BOM')\n```\n\n```{r data23, eval=FALSE}\nmeasurements <- read.csv(file = \"measurements.csv\")\n```\n:::\n\nWe can then add `measurements` to `chol` as two additional columns and save the resulting data frame as `chol_full` using the code below.\n\n::: panel-tabset\n## R Code\n```{r data24.1, eval = FALSE}\nchol_full <- cbind(chol, measurements)\nhead(chol_full)\n```\n\n## Output\n```{r data24.2, echo = FALSE}\nchol_full <- cbind(chol, measurements)\nhead(chol_full)\n```\n:::\n\nAnother way to easily create a new variable in a data frame is to use the `$` operator. We can simply add the name of the data frame to the left of `$` and our new variable name to the right. Then we can set this variable to be any pre-existing vector, or calculate a new vector based on variables from the data frame.\n\nFor example, if we wanted to create a new variable, `bmi`, in `chol` which shows the BMI of each patient, then we can use the following code.\n\n::: panel-tabset\n## R Code\n```{r data25.1, eval = FALSE}\nchol_full$bmi <- chol_full$weight/(chol_full$height)^2\nhead(chol_full)\n```\n\n## Output\n```{r data25.2, echo = FALSE}\nchol_full$bmi <- chol_full$weight/(chol_full$height)^2\nhead(chol_full)\n```\n:::\n\n:::{.question}\n::::{.question-header}\nTask\n::::\n::::{.question-container}\nIn the `education` data frame, create a new variable called `ratio` which calculates the pupil to teacher ratio in each level of education. That is,\n\n$$\\mbox{ratio}=\\textstyle\\frac{\\mbox{puils}}{\\mbox{teachers}}$$\n`r hide(\"Solution\")`\n::: panel-tabset\n## R Code\n```{r data-ans11}\neducation$ratio <- education$pupils/education$teachers\n```\n:::\n`r unhide()`\n::::\n:::\n\nNow suppose that information on a fourteenth subject is known but has not been included in the original `chol` data frame. This data is shown in @tbl-subject-table below.\n\n```{r subject-setup, echo=FALSE}\nsubject <- data.frame(id = \"P461\", ldl = 148, hdl = 78, trig = 120, age = 41, gender = \"male\", \n                      smoke = \"current\", weight = 84.05, height = 1.79)\nsubject <- as.matrix(subject)\n```\n\n```{r subject-table, echo=FALSE}\n#| tbl-cap: \"Cholesterol data for the fourteenth patient.\"\n#| label: tbl-subject-table\n\nkable(subject)\n```\n\nIn this case we can add the new subject as an additional row using the `rbind()` function.\n\nFirst, we need to create a data frame containing the information for this subject. In order for us to add this data frame as a row to `chol_full`, it needs to have the same number of variables. Therefore, we also need to calculate the BMI for this subject and call it `bmi`. We can do all this with the following code.\n\n::: panel-tabset\n## R Code\n```{r data26}\nsubject <- data.frame(id = \"P461\", ldl = 148, hdl = 78, trig = 120, age = 41, \n                      gender = \"male\", smoke = \"current\", weight = 84.05,\n                      height = 1.79)\n\nsubject$bmi <- subject$weight/(subject$height)^2\n```\n:::\n\nNow we can add this subject to `chol_full` using the code below.\n\n::: panel-tabset\n## R Code\n```{r data27.1, eval = FALSE}\nchol_full <- rbind(chol_full, subject)\ntail(chol_full)\n```\n\n## Output\n```{r data27.2, echo = FALSE}\nchol_full <- rbind(chol_full, subject)\ntail(chol_full)\n```\n:::\n\nNote that `tail()` is a function very similar to `head()`, but rather than showing the first 6 rows by default, it shows the last 6.\n\n---\n\nSections [1.11.2 Creating New Variables in a Data Frame](https://read.kortext.com/reader/pdf/92741/54){target=\"_blank\"} and [1.13 Tables](https://read.kortext.com/reader/pdf/92741/62){target=\"_blank\"} of *Probability and Statistics with R* describe how to create new variables.\n\nSee @sec-cut to learn how to create a new variable in a data frame by breaking an exisiting variable into different levels.\n\n\n\n","srcMarkdownNoYaml":"\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo=TRUE, eval=TRUE, comment=NA)\nlibrary(webexercises)\nlibrary(PASWR2)\nlibrary(knitr)\nlibrary(kableExtra)\nlibrary(ggplot2)\nlibrary(tidyverse)\n```\n\n```{r read1, echo = FALSE}\nchol <- read.table(file = \"Data/chol.txt\", header = TRUE, fileEncoding = 'UTF-8-BOM')\neducation <- read.csv(file = \"Data/edu.csv\", na.strings = \"*\", fileEncoding = 'UTF-8-BOM')\n```\n\n## Checking variable types {#sec-checking}\n\nOnce a data frame has been read into R, it is always a good idea to examine its contents using the `str()` function to see the **structure** of the data object. We have already seen the `str()` function in [Lab 2](https://moodle.gla.ac.uk/pluginfile.php/9073095/mod_resource/content/2/02-data.html#sec-df){target=\"_blank\"} but as a reminder, it shows us the type of vector each column in a data frame is saved as.\n\nRunning the following code tells us that the four variables `ldl`, `hdl`, `trig` and `age` are all integer vectors and that `id`, `gender` and `smoke` are character vectors.\n\n::: panel-tabset\n## R Code\n```{r data1.1, eval = FALSE}\nstr(chol)\n```\n\n## Output\n```{r data1.2, echo = FALSE}\nstr(chol)\n```\n:::\n\nBecause `gender` only takes the values `\"female\"` or `\"male\"` in this case, and `smoke` is categorised into three levels, `\"no\"`, `\"ex-smoker\"` and `\"current\"`, it makes sense to treat both these variables as factors instead of character vectors.\n\nWe can use what we learned in [Lab 2](https://moodle.gla.ac.uk/pluginfile.php/9073095/mod_resource/content/2/02-data.html#sec-fact){target=\"_blank\"} to change these variables into factors. \n\n::: panel-tabset\n## R Code\n```{r data2}\nchol$gender <- factor(x = chol$gender, levels = c(\"female\", \"male\"))\nchol$smoke <- factor(x = chol$smoke, levels = c(\"no\", \"ex-smoker\", \"current\"))\n```\n:::\n\nNow using `str()` to check the type of vector each column is saved as shows us that `gender` and `smoke` are both now factors.\n\n::: panel-tabset\n## R Code\n```{r data3.1, eval = FALSE}\nstr(chol)\n```\n\n## Output\n```{r data3.2, echo = FALSE}\nstr(chol)\n```\n:::\n\n:::{.question}\n::::{.question-header}\nTask\n::::\n::::{.question-container .webex-check}\n```{r data-ans1, echo=FALSE}\nopts1 <- c(\"character\", \"logical\", \"numeric\", answer=\"integer\", \"factor\")\n```\nWhat type of variable is `schools` saved as in the `education` data frame?\n`r mcq(opts1)`\n\n`r hide(\"Solution\")`\nUsing the `str()` function shows us that `schools` is saved as an integer variable.\n\n::: panel-tabset\n## R Code\n```{r data-ans2.1, eval = FALSE}\nstr(education)\n```\n\n## Output\n```{r data-ans2.2, echo = FALSE}\nstr(education)\n```\n:::\n`r unhide()`\n::::\n:::\n\n:::{.question}\n::::{.question-header}\nTask\n::::\n::::{.question-container .webex-check}\n```{r, echo=FALSE}\nopts <- c(\"`data.frame`\", answer=\"`factor`\", \"`matrix`\")\n```\n\nComplete the code to change the variables `year` and `level` in `education` to be factor variables.\n\n::: panel-tabset\n## R Code\n::: {.webex-code}\n`education$year <- ``r mcq(opts)``(x = ``r fitb(c(\"education$year\", \"education[, \\\"year\\\"]\", \"education[, 1]\"))``,`\n<ul style=\"margin-top: 0em; margin-left: 15em;\">\n\n`levels = ``r fitb(c(\"c(\\\"2016\\\", \\\"2017\\\", \\\"2018\\\", \\\"2019\\\", \\\"2020\\\", \\\"2021\\\", \\\"2022\\\")\", \"2016:2022\", \"c(2016, 2017, 2018, 2019, 2020, 2021, 2022)\"), width=15)``)`\n</ul>\n\n<p>\n</p>\n\n`education$level <- ``r mcq(opts)``(x = ``r fitb(c(\"education$level\", \"education[, \\\"level\\\"]\", \"education[, 2]\"))``,`\n<ul style=\"margin-top: 0em; margin-left: 15em;\">\n\n`levels = c(``r fitb(\"\\\"ELC\\\", \\\"Primary\\\", \\\"Secondary\\\"\", width=15)``))`\n</ul>\n:::\n:::\n\n`r hide(\"Solution\")`\n\n::: panel-tabset\n## R Code\n```{r data-ans3}\neducation$year <- factor(x = education$year,\n                         levels = 2016:2022)\n\neducation$level <- factor(x = education$level,\n                          levels = c(\"ELC\", \"Primary\", \"Secondary\"))\n```\n:::\n`r unhide()`\n::::\n:::\n\n---\n\nRefer to [Section 1.11 Working with Data](https://read.kortext.com/reader/pdf/92741/47){target=\"_blank\"} of *Probability and Statistics with R* to learn more about checking the setup of a data set.\n\n\n## Dealing with `NA` values\n\nData sets will often have missing values for a variety of different reasons; maybe because of human error, maybe because information was not disclosed or maybe because of a failed experiment for example. When data is correctly read into R these unknown values will be denoted by `NA`. In order to conduct analysis or perform calculations on your data, you may wish to remove these missing values from your data set. **Always think about whether this is an appropriate thing to do.**\n\nOne way in which we can remove missing values from a data set is to use the function `na.omit()`. This will return the data frame with any 'incomplete cases' removed. That is, any rows that have `NA` as the value for any variable will be removed from the data frame.\n\nLooking at `chol`, we can see that there are missing values in rows 3, 7 and 9.\n\n::: panel-tabset\n## R Code\n```{r chol1.1, eval = FALSE}\nchol\n```\n\n## Output\n```{r chol1.2, echo = FALSE}\ncbind(\" \" = as.character(1:13), chol)\n```\n:::\n\nIf we run the following code, then these rows are removed from the data frame and we are left with only the 'complete cases'.\n\n::: panel-tabset\n## R Code\n```{r data4.1, eval = FALSE}\nna.omit(chol)\n```\n\n## Output\n```{r data4.2, echo = FALSE}\nna.omit(chol)\n```\n:::\n\nNote that `na.omit()` preserves the original row labels. This means that there are no rows labelled 3, 7 or 9 in the resulting data frame because they have been completely removed.\n\n`complete.cases()` is another useful function that can be used to remove rows that have `NA` values. This returns a logical vector, the same length as the number of rows of the data frame, that indicates whether a row contains any `NA` values (`FALSE`), or whether it is 'complete' (`TRUE`).\n\n::: panel-tabset\n## R Code\n```{r data5.1, eval = FALSE}\ncomplete.cases(chol)\n```\n\n## Output\n```{r data5.2, echo = FALSE}\ncomplete.cases(chol)\n```\n:::\n\nAgain we can see that the rows with missing values in `chol` are rows 3, 7 and 9 (since the third, seventh and ninth values in the output above are all `FALSE`). We can then use this logical vector to extract the rows which are complete from `chol`.\n\n::: panel-tabset\n## R Code\n```{r data6.1, eval = FALSE}\nchol[complete.cases(chol), ]\n```\n\n## Output\n```{r data6.2, echo = FALSE}\nchol[complete.cases(chol), ]\n```\n:::\n\nHere, using `na.omit()` and `complete.cases()` have returned the same output.\n\n:::{.question}\n::::{.question-header}\nTask\n::::\n::::{.question-container .webex-check}\n```{r data-ans4, echo=FALSE}\nopts2 <- c(\"none\", \"8 only\", \"8 and 15\", answer=\"8 and 16\", \"16 only\")\n```\n\nWhich rows in `education` have missing values?\n`r mcq(opts2)`\n\n`r hide(\"Solution\")`\nUsing `complete.cases()` shows us that rows 8 and 16 of `education` are incomplete and therefore contain `NA` values.\n\n::: panel-tabset\n## R Code\n```{r data-ans5.1, eval = FALSE}\ncomplete.cases(education)\n```\n\n## Output\n```{r data-ans5.2, echo = FALSE}\ncomplete.cases(education)\n```\n:::\n`r unhide()`\n::::\n:::\n\n:::{.question}\n::::{.question-header}\nTask\n::::\n::::{.question-container .webex-check}\nWrite code to remove all rows in `education` which contain `NA` values.\n\n::: panel-tabset\n## R Code\n::: {.webex-code}\n`r fitb(c(\"education[complete.cases(education), ]\", \"na.omit(education)\", \"education[!is.na(education$teachers), ]\"))`\n:::\n:::\n\n`r hide(\"Solution\")`\nIncomplete observations can be removed from `education` using any of the following lines of code.\n\n::: panel-tabset\n## R Code\n```{r data-ans6, eval=FALSE}\nna.omit(education)\neducation[complete.cases(education), ]\neducation[!is.na(education$teachers), ]\n```\n:::\n`r unhide()`\n\n::::\n:::\n\nIn the case where we only want to know which entries of a vector or specific variable in a data frame are `NA`, we can use the function `is.na()`. For example, if missing values in the `trig` variable were not of concern but we wanted to identify missing values in the `smoke` column, we could use the following code.\n\n::: panel-tabset\n## R Code\n```{r data7.1, eval = FALSE}\nis.na(chol$smoke)\n```\n\n## Output\n```{r data7.2, echo = FALSE}\nis.na(chol$smoke)\n```\n:::\n\nWe can see that only the third row has the value `NA` for `smoke`, since the third element in the output from `is.na()` above is `TRUE`. In order to remove the row where `smoke` has a missing value, we can use the following code to index the `chol` data frame.\n\n::: panel-tabset\n## R Code\n```{r data8.1, eval = FALSE}\nchol[!is.na(chol$smoke), ]\n```\n\n## Output\n```{r data8.2, echo = FALSE}\nchol[!is.na(chol$smoke), ]\n```\n:::\n\nNote that we use `!` in front of `is.na()` so that the logical vector returned has the value `TRUE` when values are complete and `FALSE` when values are missing i.e. `NA`.\n\n---\n\nYou can look at further examples of dealing with missing data in [Section 1.11.1 Dealing with `NA` Values](https://read.kortext.com/reader/pdf/92741/51){target=\"_blank\"} of *Probability and Statistics with R*.\n\n\n## Sorting data frames\n\nWhen investigating your data sets, you may want to order the values of a particular variable in increasing or decreasing order. This is easily done using the `sort()` function.\n\nFor example, we can view the ages of all subjects in `chol`, in increasing order, using the code below.\n\n::: panel-tabset\n## R Code\n```{r data9.1, eval = FALSE}\nsort(chol$age)\n```\n\n## Output\n```{r data9.2, echo = FALSE}\nsort(chol$age)\n```\n:::\n\nNote that if we wanted to view these ages in decreasing order, we would add the argument `decreasing = TRUE` to the `sort()` function.\n\n:::{.question}\n::::{.question-header}\nTask\n::::\n::::{.question-container .webex-check}\nWhat is the largest value for `pupils` from the `education` data frame?\n`r fitb(c(\"400312\", \"400,312\"))`\n\n`r hide(\"Solution\")`\n::: panel-tabset\n## R Code\n```{r data-ans7.1, eval = FALSE}\nsort(education$pupils, decreasing = TRUE)[1]\n```\n\n## Output\n```{r data-ans7.2, echo = FALSE}\nsort(education$pupils, decreasing = TRUE)[1]\n```\n:::\n`r unhide()`\n::::\n:::\n\nThe downside of using `sort()` is that we can only see the values from one variable of a data frame. If instead we wanted to order all subjects in `chol` from the youngest to the oldest and still see the values of all the other variables, we can use the function `order()`.\n\n`order()` will return a vector showing which row has the smallest value, then the second smallest value and so on. For example, the following code shows us that the fourth subject in `chol` is the youngest and the thirteenth subject is the eldest.\n\n::: panel-tabset\n## R Code\n```{r data10.1, eval = FALSE}\norder(chol$age)\n```\n\n## Output\n```{r data10.2, echo = FALSE}\norder(chol$age)\n```\n:::\n\nWe can then use this vector to index the full data frame `chol` and see all the variables for each subject at once.\n\n::: panel-tabset\n## R Code\n```{r data11.1, eval = FALSE}\nchol[order(chol$age), ]\n```\n\n## Output\n```{r data11.2, echo = FALSE}\nchol[order(chol$age), ]\n```\n:::\n\nIn the output above, note that there are multiple subjects aged 32, 42 and 48. After ordering by `age`, R automatically shows these subjects with the same age in order of increasing row number. We could however add a second or third argument to `order()` to order the rows by another variable in the case where there are repeated values of the first variable.\n\nFor example, the following code orders all the subjects in `chol` by `age` first, and then for any subjects that are the same age, they will then be sorted in order of increasing `ldl`.\n\n::: panel-tabset\n## R Code\n```{r data12.1, eval = FALSE}\nchol[order(chol$age, chol$ldl), ]\n```\n\n## Output\n```{r data12.2, echo = FALSE}\nchol[order(chol$age, chol$ldl), ]\n```\n:::\n\n:::{.question}\n::::{.question-header}\nTask\n::::\n::::{.question-container}\nWrite code to sort the observations from `education` in decreasing order of the number of pupils.\n\n`r hide(\"Solution\")`\nWe need to include the argument `decreasing = TRUE` within the function `order()` so that the observations are ordered from largest number of pupils to the smallest number of pupils. We can use the `order()` function within square brackets to show all variables in the data frame in order of decreasing number of pupils.\n\n::: panel-tabset\n## R Code\n```{r data-ans8.1, eval = FALSE}\neducation[order(education$pupils, decreasing = TRUE), ]\n```\n\n## Output\n```{r data-ans8.2, echo = FALSE}\neducation[order(education$pupils, decreasing = TRUE), ]\n```\n:::\n`r unhide()`\n::::\n:::\n\n---\n\nLook at [Section 1.11.3 Sorting a Data Frame by One or More of Its Columns](https://read.kortext.com/reader/pdf/92741/55){target=\"_blank\"} of *Probability and Statistics with R* to learn more about sorting and ordering data sets.\n\n\n## Subsetting\n\nWhen we want to only view particular elements of a data frame, this is known as subsetting the data. This is useful if you're dealing with extremely large data sets and only want to analyse female subjects, or subjects who are all from the same country for example. Subsetting the data means that you would extract only these subjects that you are actually interested in.\n\nA useful function for extracting elements of a data frame is the function `subset()` (which we first saw in [Lab 1](https://moodle.gla.ac.uk/pluginfile.php/9072880/mod_resource/content/5/01-vectors.html#filter){target=\"_blank\"}). This allows us to extract the elements of a data frame which meet particular conditions. The arguments that `subset()` takes are:\n\n* `x =`: this is the data frame that we want to extract particular elements from.\n* `subset =`: this is a logical statement which determines the elements to keep in the subsetted data frame.\n* `select =`: this shows the column or columns from the data frame which the logical statement should be applied to.\n\nFor example, if we wanted to view the subjects in `chol` who have an LDL of greater than 170, then we can use the following code.\n\n::: panel-tabset\n## R Code\n```{r data13.1, eval = FALSE}\nsubset(x = chol, subset = ldl > 170, select = ldl)\n```\n\n## Output\n```{r data13.2, echo = FALSE}\nsubset(x = chol, subset = ldl > 170, select = ldl)\n```\n:::\n\nThis shows us that there are three patients with LDL greater than 170 (`subset = ldl > 170`) and we can also see the values of LDL for these patients (`select = ldl`).\n\nIf we wanted to see the values of the other variables in the data frame for only those patients with LDL greater than 170, then we can simply leave out the `select =` argument.\n\n::: panel-tabset\n## R Code\n```{r data14.1, eval = FALSE}\nsubset(x = chol, subset = ldl > 170)\n```\n\n## Output\n```{r data14.2, echo = FALSE}\nsubset(x = chol, subset = ldl > 170)\n```\n:::\n\nNote that it is also possible to subset a data frame using logical statements within square brackets, `[ ]`. We could return the same output as above by indexing the `chol` using the following code.\n\n::: panel-tabset\n## R Code\n```{r data15.1, eval = FALSE}\nchol[chol$ldl > 170, ]\n```\n\n## Output\n```{r data15.2, echo = FALSE}\nchol[chol$ldl > 170, ]\n```\n:::\n\n:::{.question}\n::::{.question-header}\nTask\n::::\n::::{.question-container}\nWrite some code to subset `education` to show the number of schools that have a collective total of more than 310,000 pupils in the years 2020, 2021 or 2022.\n\n`r hide(\"Solution\")`\nThe data frame that we want to subset is `education`, so this is what we'll feed in to the argument `x =`.\n\nSince the question asks us to look for a collective total of more than 310,000 pupils, this means we want to only see the rows where the value for `pupils` is greater than 310,000. We also only want to see rows from the years 2020, 2021 or 2022. Because `year` is a factor, we need to specify each level that we are interested in. This means that we are looking for rows in which `pupils > 310000` AND `year == \"2020\"` or `year == \"2021\"` or `year == \"2021\"`. This is quite a lengthy logical statement in the following code.\n\nThe question also asks us to only show the number of schools for which these statements are true i.e. the column `schools`. To do this, we simply feed this variable to the `select =` argument.\n\n::: panel-tabset\n## R Code\n```{r data-ans9.1, eval=FALSE}\nsubset(x = education,\n       subset = pupils > 310000 & year == \"2020\" | \n         pupils > 310000 & year == \"2021\" | \n         pupils > 310000 & year == \"2022\",\n       select = schools)\n```\n:::\n\nA way we can shorten the logical statement in the `subset =` argument is to use the operator `%in%`. This will search for values in a vector and return the rows in which any of these values appear.\n\n::: panel-tabset\n## R Code\n```{r data-ans9.2.1, eval = FALSE}\nsubset(x = education,\n       subset = pupils > 310000 & year %in% c(\"2020\", \"2021\", \"2022\"),\n       select = schools)\n```\n\n## Output\n```{r data-ans9.2.2, echo = FALSE}\nsubset(x = education,\n       subset = pupils > 310000 & year %in% c(\"2020\", \"2021\", \"2022\"),\n       select = schools)\n```\n:::\n`r unhide()`\n::::\n:::\n\n---\n\nYou can read more about subsetting data frames in [Section 1.12 Using Logical Operators with Data Frames](https://read.kortext.com/reader/pdf/92741/58){target=\"_blank\"} in *Probability and Statistics with R*.\n\n\n## Summarising data\n\nData sets will often contain a lot of information which is not easy to interpret at a glance. It is therefore useful to be able to summarise the data they contain, in appropriate ways for each different type of variable.\n\nOne of the simplest functions to help summarise a data frame is the `summary()` function.\n\n::: panel-tabset\n## R Code\n```{r data16.1, eval = FALSE}\nsummary(chol)\n```\n\n## Output\n```{r data16.2, echo = FALSE}\nsummary(chol)\n```\n:::\n\nThe output from `summary()` shows information for each column in the data frame you provide as the argument. For numerical variables, we are shown summary statistics such as the minimum value, the mean or the 3rd quartile. For factor variables, we are shown how many observations there are in each level of the factor. If there are any `NA` values in a column, the total number of these will also be shown for each variable.\n\nWhen a data frame contains categorical variables, a neater way to summarise the counts of the different levels is in contingency tables. These show counts of how many times each level of a categorical variable appeared in the data frame. The function to create contingency tables in R is `table()`. The only argument that `table()` needs is the factor variable you want to summarise.\n\nFor example, we can quickly show counts of how many subjects in `chol` fall into each of the three levels of the `smoke` variable using the following code.\n\n::: panel-tabset\n## R Code\n```{r data17.1, eval = FALSE}\ntable(chol$smoke)\n```\n\n## Output\n```{r data17.2, echo = FALSE}\ntable(chol$smoke)\n```\n:::\n\nIf we wanted to further split these counts by the variable `gender`, then we simply add this as a second argument to the `table()` function.\n\n::: panel-tabset\n## R Code\n```{r data18.1, eval = FALSE}\nsmoke_counts <- table(chol$smoke, chol$gender)\nsmoke_counts\n```\n\n## Output\n```{r data18.2, echo = FALSE}\nsmoke_counts <- table(chol$smoke, chol$gender)\nsmoke_counts\n```\n:::\n\nWe can easily compute the sums of rows or columns in a table using the function `margin.table()`. Here we need to provide `margin.table()` with the following arguments:\n\n* `x =`: this is the table you want to sum over.\n* `margin =`: this tells R whether you want to sum over rows (set the value to 1), or columns (set the value to 2).\n\nFor example, we can use the table `smoke_counts`, created above, to count the number of female and male subjects for whom we know their smoking status, using `margin.table()`.\n\n::: panel-tabset\n## R Code\n```{r data19.1, eval = FALSE}\nmargin.table(x = smoke_counts, margin = 2)\n```\n\n## Output\n```{r data19.2, echo = FALSE}\nmargin.table(x = smoke_counts, margin = 2)\n```\n:::\n\nAnother useful function to use with tables is `prop.table()`. This takes the same arguments as `margin.table()` but shows row or column proportions, rather than sums.\n\nFor example, to calculate the proportions of current smokers, ex-smokers and non-smokers that are female and male, we can use the following code.\n\n::: panel-tabset\n## R Code\n```{r data20.1, eval = FALSE}\nprop.table(x = smoke_counts, margin = 1)\n```\n\n## Output\n```{r data20.2, echo = FALSE}\nprop.table(x = smoke_counts, margin = 1)\n```\n:::\n\nSuppose you wanted to calculate summary statistics for one variable in a data frame, but have it split by the levels of a different categorical variable.\n\nThe function in R which calculates a summary statistic for one numeric variable, split by the levels of a factor is `tapply()`. The arguments that `tapply()` can take are as follows:\n\n* `X =`: this is the numeric variable that you want to apply the function calculating some summary statistic to.\n* `INDEX =`: this is a **list** containing the categorical variable (or variables) you want to split the calculation of the summary statistic across.\n* `FUN =`: this is the name of the function you want to apply to the numeric variable. Examples include `mean`, `median`, `max`, `min`, `mode`, `sd` etc.\n\nIn the case where we are interested in knowing the mean HDL for subjects who were current smokers, subjects who were ex-smokers and subjects who were non-smokers, we can use `tapply()`.\n\n::: panel-tabset\n## R Code\n```{r data21.1, eval = FALSE}\ntapply(X = chol$hdl, INDEX = list(chol$smoke), FUN = mean)\n```\n\n## Output\n```{r data21.2, echo = FALSE}\ntapply(X = chol$hdl, INDEX = list(chol$smoke), FUN = mean)\n```\n:::\n\nWe can see, for example, that the mean HDL for non-smokers is 61.17. <!--units?-->\n\nThe list provided to the `INDEX =` argument can contain more than one categorical variable. For example, we can calculate the mean HDL of females and males for each level of the `smoke` variable using the following code.\n\n::: panel-tabset\n## R Code\n```{r data22.1, eval = FALSE}\ntapply(X = chol$hdl, INDEX = list(chol$smoke, chol$gender), FUN = mean)\n```\n\n## Output\n```{r data22.2, echo = FALSE}\ntapply(X = chol$hdl, INDEX = list(chol$smoke, chol$gender), FUN = mean)\n```\n:::\n\nNow we can see that the mean HDL for females who are non-smokers is 57.20. <!-- units--> The mean HDL for males who are ex-smokers is `NA` because there are no males included in `chol` who are ex-smokers.\n\n:::{.question}\n::::{.question-header}\nTask\n::::\n::::{.question-container .webex-check}\nWhat is the mean total number of teachers in primary schools across all years?\n`r fitb(c(\"25055\", \"25056\", \"25055.5\", \"25055.50\", \"25055.500\", \"25055.5000\"))`\n\n`r hide(\"Solution\")`\nIn order to find this value we want to use the function `tapply()`. `teachers` is the column we want to calculate the `mean` for, but make sure to split this by the different levels in the `level` column.\n\n`teachers` contains some `NA` values, which when passed to the function `mean` will return another `NA` value unless you provide to `tapply()` the additional argument `na.rm = TRUE`. This tells R to ignore the `NA` values when calculating the mean and only use those rows which have a numerical value.\n\n::: panel-tabset\n## R Code\n```{r data-ans10.1, eval = FALSE}\ntapply(X = education$teachers, INDEX = list(education$level),\n       FUN = mean, na.rm = TRUE)\n```\n\n## Output\n```{r data-ans10.2, echo = FALSE}\ntapply(X = education$teachers, INDEX = list(education$level),\n       FUN = mean, na.rm = TRUE)\n```\n:::\n`r unhide()`\n::::\n:::\n\n---\n\nTo read more on creating tables and summarising data in R, see Sections [1.13 Tables](https://read.kortext.com/reader/pdf/92741/62){target=\"_blank\"} and [1.14 Summarizing Functions](https://read.kortext.com/reader/pdf/92741/66){target=\"_blank\"} in *Probability and Statistics with R*.\n\n\n## Creating variables\n\nIn the case where we have another vector or data frame that we wish to join to an existing one, we can do this using one of the functions `cbind()` or `rbind()`.\n\n* `cbind()` combines the vectors or data frames together by making additional columns, whereas \n\n* `rbind()` combines them by adding the new vector or data frame as additional rows.\n\nLet's see an example to understand how this works. The file *measurements.csv* contains information on the heights and weights of all 13 patients in the original `chol` data frame. We can begin by reading it in to the **Environment** tab using the following code.\n\n::: panel-tabset\n## R Code\n```{r read-measurements, echo=FALSE}\nmeasurements <- read.csv(file = \"Data/measurements.csv\", fileEncoding = 'UTF-8-BOM')\n```\n\n```{r data23, eval=FALSE}\nmeasurements <- read.csv(file = \"measurements.csv\")\n```\n:::\n\nWe can then add `measurements` to `chol` as two additional columns and save the resulting data frame as `chol_full` using the code below.\n\n::: panel-tabset\n## R Code\n```{r data24.1, eval = FALSE}\nchol_full <- cbind(chol, measurements)\nhead(chol_full)\n```\n\n## Output\n```{r data24.2, echo = FALSE}\nchol_full <- cbind(chol, measurements)\nhead(chol_full)\n```\n:::\n\nAnother way to easily create a new variable in a data frame is to use the `$` operator. We can simply add the name of the data frame to the left of `$` and our new variable name to the right. Then we can set this variable to be any pre-existing vector, or calculate a new vector based on variables from the data frame.\n\nFor example, if we wanted to create a new variable, `bmi`, in `chol` which shows the BMI of each patient, then we can use the following code.\n\n::: panel-tabset\n## R Code\n```{r data25.1, eval = FALSE}\nchol_full$bmi <- chol_full$weight/(chol_full$height)^2\nhead(chol_full)\n```\n\n## Output\n```{r data25.2, echo = FALSE}\nchol_full$bmi <- chol_full$weight/(chol_full$height)^2\nhead(chol_full)\n```\n:::\n\n:::{.question}\n::::{.question-header}\nTask\n::::\n::::{.question-container}\nIn the `education` data frame, create a new variable called `ratio` which calculates the pupil to teacher ratio in each level of education. That is,\n\n$$\\mbox{ratio}=\\textstyle\\frac{\\mbox{puils}}{\\mbox{teachers}}$$\n`r hide(\"Solution\")`\n::: panel-tabset\n## R Code\n```{r data-ans11}\neducation$ratio <- education$pupils/education$teachers\n```\n:::\n`r unhide()`\n::::\n:::\n\nNow suppose that information on a fourteenth subject is known but has not been included in the original `chol` data frame. This data is shown in @tbl-subject-table below.\n\n```{r subject-setup, echo=FALSE}\nsubject <- data.frame(id = \"P461\", ldl = 148, hdl = 78, trig = 120, age = 41, gender = \"male\", \n                      smoke = \"current\", weight = 84.05, height = 1.79)\nsubject <- as.matrix(subject)\n```\n\n```{r subject-table, echo=FALSE}\n#| tbl-cap: \"Cholesterol data for the fourteenth patient.\"\n#| label: tbl-subject-table\n\nkable(subject)\n```\n\nIn this case we can add the new subject as an additional row using the `rbind()` function.\n\nFirst, we need to create a data frame containing the information for this subject. In order for us to add this data frame as a row to `chol_full`, it needs to have the same number of variables. Therefore, we also need to calculate the BMI for this subject and call it `bmi`. We can do all this with the following code.\n\n::: panel-tabset\n## R Code\n```{r data26}\nsubject <- data.frame(id = \"P461\", ldl = 148, hdl = 78, trig = 120, age = 41, \n                      gender = \"male\", smoke = \"current\", weight = 84.05,\n                      height = 1.79)\n\nsubject$bmi <- subject$weight/(subject$height)^2\n```\n:::\n\nNow we can add this subject to `chol_full` using the code below.\n\n::: panel-tabset\n## R Code\n```{r data27.1, eval = FALSE}\nchol_full <- rbind(chol_full, subject)\ntail(chol_full)\n```\n\n## Output\n```{r data27.2, echo = FALSE}\nchol_full <- rbind(chol_full, subject)\ntail(chol_full)\n```\n:::\n\nNote that `tail()` is a function very similar to `head()`, but rather than showing the first 6 rows by default, it shows the last 6.\n\n---\n\nSections [1.11.2 Creating New Variables in a Data Frame](https://read.kortext.com/reader/pdf/92741/54){target=\"_blank\"} and [1.13 Tables](https://read.kortext.com/reader/pdf/92741/62){target=\"_blank\"} of *Probability and Statistics with R* describe how to create new variables.\n\nSee @sec-cut to learn how to create a new variable in a data frame by breaking an exisiting variable into different levels.\n\n\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css","include/webex.css"],"toc":true,"include-after-body":["include/webex.js"],"embed-resources":true,"output-file":"02-data.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.553","editor":"source","theme":["cosmo","custom.scss"],"title":"Working With Data"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}