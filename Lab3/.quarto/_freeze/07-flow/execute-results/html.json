{
  "hash": "c9159e0a7cb10686e359c7df3ac2a65f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Flow Control\"\n---\n\n\n\n\nFlow control is the term used to describe the order that your code is carried out. Usually this just happens line by line, but there may be cases where you want to repeat and update certain code over and over. To save you time having to type out a lot of repeating code, there are functions in R which can help you to repeat certain operations.\n\nThe `for()` function allows you to repeat lines of code for a given number of repetitions. Sometimes using the `for()` function is referred to as a **for loop** because once you have run multiple lines of code, it loops back to the beginning and does it all again. The setup is:\n\n::: panel-tabset\n## R Code\n\n::: {.cell}\n\n```{.r .cell-code}\nfor(name in vector){\n  statements\n}\n```\n:::\n\n:::\n\n* `name`: this is the name you want to use for the index in each iteration of the repeated statements. Most commonly this is given the value `i`.\n* `vector`: this is a vector which is the same length as the number of times you want to repeat the statements.\n* `statements`: these are the lines of code you want to repeat a number of times.\n\nIn order to fully understand how the `for()` function works, let's look at an example. We could use the `for()` function to print the numbers 1 up to 5.\n\n::: panel-tabset\n## R Code\n\n::: {.cell}\n\n```{.r .cell-code}\nfor(i in 1:5){\n  print(i)\n}\n```\n:::\n\n\n## Ouptut\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n```\n\n\n:::\n:::\n\n:::\n\nHere, we have assigned the value `i` to the `name` argument and the vector is `1:5`. The `:` operator returns the sequence of numbers from 1 to 5 in this case.\n\nThe for loop will first of all give `i` the value 1 and then run the statements within `{ }`, so here it will run `print(1)`. `print()` is a function we haven't seen yet, but it just 'prints' the arguments to the R console so we will see the value 1 written there.\n\nNext, the for loop will update the value of `i` to the next one given in the `vector` argument i.e. it will assign the value 2 to `i`. Then it will again run `print(2)` and update the value of `i` again. This will repeat until `i` has taken all the values given in the `vector` argument.\n\n:::{.question}\n::::{.question-header}\nTask\n::::\n::::{.question-container .webex-check}\nComplete the following code to sum together the numbers 1 to 12.\n\n::: panel-tabset\n## R Code\n::: {.webex-code}\n      \n`sum <- `<input class='webex-solveme nospaces' size='1' data-answer='[\"0\"]'/>\n     \n<ul style=\"margin-top: 1.8em; margin-left: -2em;\">\n`for(i in `<input class='webex-solveme nospaces' size='4' data-answer='[\"1:12\"]'/>`){`\n</ul>\n<ul style=\"margin-top: -0.8em; margin-left: -1em\">\n`sum <- sum + `<input class='webex-solveme nospaces' size='1' data-answer='[\"i\"]'/>\n</ul>\n<ul style=\"margin-top: -0.8em; margin-left: -2em\">\n`}`\n</ul>\n\n:::\n:::\n\n\n<div class='webex-solution'><button>Solution</button>\n\nWe start by creating the vector `sum` to which each value 1, 2, ..., 12 can be added. Initially it needs to take the value 0.\n\nWithin the function `for()`, we want `i` to, in turn, take each value 1, 2, ..., 12, so we need to provide a vector of these values (`1:12`). `sum` should then be updated each time `i` takes a new value, by adding it on to the old value of `sum`.\n\n::: panel-tabset\n## R Code\n\n::: {.cell}\n\n```{.r .cell-code}\nsum <- 0\n\nfor(i in 1:12){\n  sum <- sum + i\n}\n```\n:::\n\n:::\n\nThis for loop starts with `sum` having the value 0. It will first assign 1 to `i` and execute the code `sum <- 0 + 1`, meaning `sum` now has the value 1.\n\n* `i` will then be updated to take the value 2 and the for loop will run the code `sum <- 1 + 2` i.e. `sum` has the value 3.\n\n* `i` will then be updated to take the value 3 and the for loop will run the code `sum <- 3 + 3` i.e. `sum` has the value 6.\n\n* $\\vdots$\n\nThis repeats until finally `i` is assigned the value 12 and the for loop updates `sum` for the last time.\n\n</div>\n\n::::\n:::\n\n:::{.question}\n::::{.question-header}\nTask\n::::\n::::{.question-container .webex-check}\nUsing the above code, what is the value of $1+2+3+...+12$?\n<input class='webex-solveme nospaces' size='7' data-answer='[\"78\",\"78.0\",\"78.00\",\"78.000\",\"78.0000\"]'/>\n\n\n<div class='webex-solution'><button>Solution</button>\n\n::: panel-tabset\n## R Code\n\n::: {.cell}\n\n```{.r .cell-code}\nsum <- 0\n\nfor(i in 1:12){\n  sum <- sum + i\n}\n\nsum\n```\n:::\n\n\n## Ouptut\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 78\n```\n\n\n:::\n:::\n\n:::\n\nRunning the code above updates `sum` several times until it takes the value 78. Therefore the value of $1+2+3+...+12=78$.\n\n</div>\n\n::::\n:::\n\nYou might not always know how many times you want to repeat certain lines of code. When this is the case the `while()` function can be used to repeat code while a given condition is satisfied. Once this condition is no longer `TRUE`, the loop will stop. The `while()` function has a similar setup to for loops.\n\n::: panel-tabset\n## R Code\n\n::: {.cell}\n\n```{.r .cell-code}\nwhile(condition){\n  statements\n}\n```\n:::\n\n:::\n\n* `condition`: this is logical statement that can take the values `TRUE` or `FALSE`. When it is true, the statements will be repeated. When it is `FALSE`, the statements will not be evaluated.\n* `statements`: these are the lines of code you want to repeat a number of times.\n\nWe could use a **while loop** to calculate the sum of the numbers 0, 1, 2, 3, 4, 5, ... up until their total first goes over 100. The code below does this by first creating the vectors `i`, which lists all the values we want to sum together, and `total`, to keep track of the sum of all the values in `i`. Initially `i` only contains the value 0 and `total` is also set to 0.\n\nBecause we only want to sum together the values in `i` until `total` first goes over 100, the condition we provide within `while()` is `total < 100` which means the while loop will continue to run only while the value of `total` is less than 100.\n\nBecause `i` starts as only 0 and `total` is set to 0, the first iteration of the while loop updates `i` to be $\\begin{bmatrix}0&1 \\end{bmatrix}^\\intercal$ and then it updates `total` to now also be 1 (since this is the sum of all the values currently in `i`). The second iteration then extends `i` to be $\\begin{bmatrix}0&1&2 \\end{bmatrix}^\\intercal$ and updates `total` again to be $0+1+2=3$. \n\nWithin the while loop, we continuously extend `i` by adding the next number in the sequence to the end of it. This is done using the function `max()` which looks at all values in a vector and returns the maximum. We then update `total` to be the sum of all the values in `i`. This is done by using the function `sum()` which sums together all values in a numeric vector. This continues until `total` reaches a value which is greater than 100, at which point the while loop stops.\n\nThe final line prints the final versions of `i` and `total` so we can see that the vector `i` contains the values 0 up to 14 and that the sum of all these values, given by `total` is 105.\n\n::: panel-tabset\n## R Code\n\n::: {.cell}\n\n```{.r .cell-code}\ni <- 0\ntotal <- 0\n\nwhile(total < 100){\n  i <- c(i, max(i)+1)\n  total <- sum(i)\n}\n\nlist(\"i\" = i, \"total\" = total)\n```\n:::\n\n\n## Ouptut\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n$i\n [1]  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14\n\n$total\n[1] 105\n```\n\n\n:::\n:::\n\n:::\n\n**If statements** are another useful form of flow control. They have a very similar set up to the `for()` and `while()` functions.\n\n::: panel-tabset\n## R Code\n\n::: {.cell}\n\n```{.r .cell-code}\nif(condition){\n  statements\n} else {\n  statements\n}\n```\n:::\n\n:::\n\n* `condition`: this is a logical statement that can take the values `TRUE` or `FALSE`. If the condition is `TRUE` then the  statements in the `{ }` immediately after will be evaluated.\n* `else`: this is an optional part of the if statement. If there is code you wish to run when the condition is `FALSE`, it is placed in the `{ }` after this statement.\n\nFor example, we can write code to tell us whether a random value generated from the standard normal distribution lies in the region [-1, 1] using the following code.\n\n::: panel-tabset\n## R Code\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- rnorm(n = 1, mean = 0, sd = 1)\nx\n\nif(x >= -1 & x <= 1){\n  print(\"x is in the region [-1, 1]\")\n} else {\n  print(\"x is not in the region [-1, 1]\")\n}\n```\n:::\n\n\n## Ouptut\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.323718\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"x is not in the region [-1, 1]\"\n```\n\n\n:::\n:::\n\n:::\n\n:::{.question}\n::::{.question-header}\nTask\n::::\n::::{.question-container .webex-check}\nWhat would the value of `y` be after running the following if statement? Try to answer without running the code yourself.\n<select class='webex-select'><option value='blank'></option><option value=''>16</option><option value='answer'>-16</option><option value=''>-8</option><option value=''>8</option><option value=''>NA</option></select>\n\n::: panel-tabset\n## R Code\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- -4\n\nif(x > 0){\n  y <- x^2\n} else {\n  y <- -(x^2)\n}\n```\n:::\n\n:::\n\n\n<div class='webex-solution'><button>Solution</button>\n\nRunning the code above updates the value of `y` to be -16.\n\n</div>\n\n::::\n:::\n\n\n---\n\nYou can read more about for loops, while loops and if statements in [Section 1.16 Flow Control](https://read.kortext.com/reader/pdf/92741/69){target=\"_blank\"} of *Probability and Statistics with R*.\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}