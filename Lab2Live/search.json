[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "S2S Lab 2",
    "section": "",
    "text": "Welcome to the second S2S lab. This lab starts by describing what R packages are and provides an introduction to the different ‘data structures’ that can be used in R. We will also start to work with some real data!\nIt’s really important to know how R handles different types of data because there are many ways that you will be working with data throughout all your statistics courses. Being able to understand and use them all is a really good foundational skill to have.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Welcome!</span>"
    ]
  },
  {
    "objectID": "01-packages.html",
    "href": "01-packages.html",
    "title": "2  Packages",
    "section": "",
    "text": "Packages are really important in R. They are collections of functions and/or data sets which you will only have access to when the specific package is installed and loaded into your RStudio session.\nBefore loading in a package to R, it must first be installed onto your device. You only need to install packages once and then they will always be ready to load into your current RStudio session. To install a package, we use the function install.packages(\"PackageName\"), where \"PackageName\" is the case sensitive name of the package.\nThe textbook Probability and Statistics with R uses the PASWR2 package throughout. To install this package, run the following code.\n\nR Code\n\n\n\ninstall.packages(\"PASWR2\")\n\n\n\n\nNow that we have a package installed, we need to load it in to the current RStudio session in order to use any of the functions or access any of the data it contains. To load a package, we use the function library(PackageName). Note that this time we do not need to wrap PackageName in quotation marks.\nTo load in the PASWR2 package, run the following code.\n\nR Code\n\n\n\nlibrary(PASWR2)\n\n\n\n\n\nFor more information on installing and loading packages, see Section 1.8 Packages in Probability and Statistics with R.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Packages</span>"
    ]
  },
  {
    "objectID": "02-data.html",
    "href": "02-data.html",
    "title": "3  Data Structures",
    "section": "",
    "text": "3.1 Arrays\nR uses various different types of ‘data structures’ which are really just ways to store information of varying types. A lot of the data structures R uses are defined in terms of vectors, so it is important you are familiar with constructing and manipulating vectors in R (see S2S Lab 1).\nSome of the common data structures we will become familiar with are;\nEach of the data structures presented here are covered using additional examples in Section 1.9 R Data Structures of Probability and Statistics with R.\nArrays are defined as multidimensional arrangements of elements. This means that rather than storing data in a one dimensional vector, you can spread the elements of this vector across multiple dimensions.\nThis sounds quite complicated so let’s look at an example. First, let’s create a long vector of the numbers 1 up to 24 to give us elements to populate this array with.\nWe can then use the array() function to turn the vector vect into an array. The array() function takes the following arguments:\nWe can turn vect into an array, called A1, using the following code.\nHere we have populated A1 with the values 1 to 24, so that it has dimensions 2 \\(\\times\\) 4 \\(\\times\\) 3. This means that we have created 3 layers where each layer is a 2 \\(\\times\\) 4 matrix.\nThe values from vect are entered into A1 going down the columns first, then moving from left to right before moving onto the next layer. This order of entering elements is called column-major order, since columns are filled in first.\nYou can learn more about creating arrays in Section 1.9.1 Arrays and Matrices of Probability and Statistics with R.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "02-data.html#sec-arrays",
    "href": "02-data.html#sec-arrays",
    "title": "3  Data Structures",
    "section": "",
    "text": "R Code\n\n\n\nvect &lt;- 1:24\n\n\n\n\n\n\ndata =: this is the vector of elements that we want to populate the array with.\ndim =: this is another vector giving the maximum number of rows first, then the maximum number of columns and finally the maximum number of ‘layers’.\n\n\n\nR CodeOutput\n\n\n\nA1 &lt;- array(data = vect, dim = c(2, 4, 3))\nA1\n\n\n\n\n\n, , 1\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    3    5    7\n[2,]    2    4    6    8\n\n, , 2\n\n     [,1] [,2] [,3] [,4]\n[1,]    9   11   13   15\n[2,]   10   12   14   16\n\n, , 3\n\n     [,1] [,2] [,3] [,4]\n[1,]   17   19   21   23\n[2,]   18   20   22   24",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "02-data.html#sec-mat",
    "href": "02-data.html#sec-mat",
    "title": "3  Data Structures",
    "section": "3.2 Matrices",
    "text": "3.2 Matrices\n\nCreating matrices\nMatrices can be thought of as two dimensional arrays i.e. they don’t have an argument saying how many layers they should contain. Therefore, matrices can also be created using the array() function and ensuring that the dim = argument is provided with a vector only of length two. This vector then corresponds to the number of rows and columns, respectively, that the matrix has.\nTo create a matrix called M1, which is populated with the elements from vect and has 6 rows and 4 columns, we can use the following code.\n\nR CodeOutput\n\n\n\nM1 &lt;- array(data = vect, dim = c(6, 4))\nM1\n\n\n\n\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    7   13   19\n[2,]    2    8   14   20\n[3,]    3    9   15   21\n[4,]    4   10   16   22\n[5,]    5   11   17   23\n[6,]    6   12   18   24\n\n\n\n\n\nSince M1 has dimensions 6 \\(\\times\\) 4, it contains 24 elements - the same number of elements as is in the vector vect. If instead we had defined dimensions which gave fewer than 24 elements for M1, then array() would go through and fill in the elements of M1 with the elements of vect in column-major order, until there were no spaces left to fill. This would mean that not all the values from vect would appear in M1.\n\nR CodeOutput\n\n\n\narray(data = vect, dim = c(6, 2))\n\n\n\n\n\n     [,1] [,2]\n[1,]    1    7\n[2,]    2    8\n[3,]    3    9\n[4,]    4   10\n[5,]    5   11\n[6,]    6   12\n\n\n\n\n\nIf we had defined the dimensions so that M1 contained more than 24 elements, then the values of vect would be repeated for as long as necessary until all of the elements of M1 have a value.\n\nR CodeOutput\n\n\n\narray(data = vect, dim = c(6, 5))\n\n\n\n\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    7   13   19    1\n[2,]    2    8   14   20    2\n[3,]    3    9   15   21    3\n[4,]    4   10   16   22    4\n[5,]    5   11   17   23    5\n[6,]    6   12   18   24    6\n\n\n\n\n\n\n\nTask\n\n\nUse the array() function and the letters vector to create a 5 \\(\\times\\) 5 matrix containing the letters of the alphabet in column-major order, up to “y”.\n\n\n\nIt is also possible to create matrices using the matrix() function. This has the advantage of allowing you to specify whether the elements should be filled in using column-major order or row-major order (where the elements are filled in from left to right along rows and then from top to bottom). The arguments that the matrix() function can be given are:\n\ndata =: this is the vector of elements that we want to fill in the matrix with.\nnrow =: this is the number of rows the matrix should contain.\nncol =: this is the number of columns the matrix should contain.\nbyrow =: this takes values TRUE or FALSE and states whether the elements should be entered in row-major order (TRUE) or column-major order (FALSE). By default, the value is FALSE and elements will be entered in column-major order if you miss out this argument.\n\nOnly one of nrow = or ncol = needs to be included in the matrix() function because R will automatically calculate how many of the non-specified argument are required, based on the length of the vector given to data =.\nWe can create the same matrix as M1 using the matrix() function. Let’s call it M2.\n\nR CodeOutput\n\n\n\nM2 &lt;- matrix(data = vect, ncol = 4, byrow = FALSE)\nM2\n\n\n\n\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    7   13   19\n[2,]    2    8   14   20\n[3,]    3    9   15   21\n[4,]    4   10   16   22\n[5,]    5   11   17   23\n[6,]    6   12   18   24\n\n\n\n\n\nIf we wanted to fill in the elements in row-major order, then we could instead use the following code.\n\nR CodeOutput\n\n\n\nM3 &lt;- matrix(data = vect, nrow = 6, byrow = TRUE)\nM3\n\n\n\n\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    5    6    7    8\n[3,]    9   10   11   12\n[4,]   13   14   15   16\n[5,]   17   18   19   20\n[6,]   21   22   23   24\n\n\n\n\n\n\n\nTask\n\n\nCreate a 5 \\(\\times\\) 5 matrix containing the first 25 letters of the alphabet using matrix(). Fill in the elements in row-major order.\n\n\n\n\n\nNaming rows and columns\n\nIt is possible to name rows and columns of a matrix. This is useful if it holds some data corresponding to different variables that you want to label, for example we might want to represent the following table, showing the number of births recorded in four different cities in Scotland in the years 2017, 2018 and 2019, as a matrix.\n\n\n\n\nTable 3.1: Recorded births in Scottish cities in 2017, 2018, 2019.\n\n\n\n\n\n\n\n2017\n2018\n2019\n\n\n\n\nEdinburgh\n5033\n4899\n4683\n\n\nGlasgow\n6852\n6548\n6553\n\n\nAberdeen\n2402\n2337\n2260\n\n\nDundee\n1493\n1488\n1417\n\n\n\n\n\n\n\n\nWe can first of all create a matrix births containing these values and then we can name the rows and columns.\n\nR CodeOutput\n\n\n\ndata &lt;- c(5033, 4899, 4683,\n          6852, 6548, 6553, \n          2402, 2337, 2260, \n          1493, 1488, 1417)\n\nbirths &lt;- matrix(data = data, nrow = 4, byrow = TRUE)\n\ncities &lt;- c(\"Edinburgh\", \"Glasgow\", \"Aberdeen\", \"Dundee\")\nyears &lt;- c(\"2017\", \"2018\", \"2019\")\n\ndimnames(births) &lt;- list(cities, years)\nbirths\n\n\n\n\n\n          2017 2018 2019\nEdinburgh 5033 4899 4683\nGlasgow   6852 6548 6553\nAberdeen  2402 2337 2260\nDundee    1493 1488 1417\n\n\n\n\n\nHere, we have used the function dimnames(). By itself, dimnames() will extract the row and column names of a matrix, but we can also set these names by using the assign operator &lt;-. We have put the two vectors on the right hand side of the &lt;- operator, meaning we want the row and column names to be these two vectors (see Appendix C for more details on the list() function).\nWe can now use either the row/column names to extract particular elements from the matrix. We do this using square brackets, [ ], similar to with vectors, but we now need to specify the row and column we are interested in.\nFor example, if we wanted to extract the number of births in Dundee in 2017, we can run either of the following lines of code.\n\nR CodeOutput\n\n\n\nbirths[\"Dundee\", \"2017\"]\n\n\n\n\n\n[1] 1493\n\n\n\n\n\n\nR CodeOutput\n\n\n\nbirths[4, 1]\n\n\n\n\n\n[1] 1493\n\n\n\n\n\nNote that when we use the row/column names, they are in quotation marks because they are saved as character vectors in R. It is important that the row you are interested in is stated first in [ ], and then the column.\n\n\nTask\n\n\nWhat is the code you would use to show the number of births in Glasgow in all 3 years?\n\n\n\nSee Appendix A to learn how to find the dimensions of whatever you extract from a matrix.\n\n\nCalculating statistics\nWe can apply a function across the rows or columns of a matrix to calculate the mean or standard deviation for example using the function apply(). The arguments that can be given to apply() include:\n\nX =: this is the matrix (or array) we want to apply the function to.\nMARGIN =: this tells R whether we want to apply the function to the rows or the columns. A value of 1 means the function will be applied to the rows and 2 means the function will be applied to each column.\nFUN =: this is the function we want to apply. It can be things like the mean (mean), median (median), or standard deviation (sd).\n\nFor example, if we wanted to know the mean births for each city across the three years, we can use the following code.\n\nR CodeOutput\n\n\n\napply(X = births, MARGIN = 1, FUN = mean)\n\n\n\n\n\nEdinburgh   Glasgow  Aberdeen    Dundee \n 4871.667  6651.000  2333.000  1466.000 \n\n\n\n\n\n\n\nTask\n\n\nWhat is the standard deviation for the number of births in 2019?",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "02-data.html#sec-fact",
    "href": "02-data.html#sec-fact",
    "title": "3  Data Structures",
    "section": "3.3 Factors",
    "text": "3.3 Factors\nFactors are similar to vectors in R, however they have additional information and are used to store categorical data, for example someone’s gender or marriage status. They record the “levels” of the categorical variable stored within the vector which each numerical value corresponds to.\nFor example, suppose you are interested in the qualification level of several university alumni. You might use a simple encoding of 1=“Bachelor’s degree”, 2=“Master’s degree” and 3=“PhD” to record these data.\nThis might give us data that looks like the following vector degree.\n\nR CodeOutput\n\n\n\ndegree1 &lt;- c(1, 1, 2, 1, 3)\ndegree1\n\n\n\n\n\n[1] 1 1 2 1 3\n\n\n\n\n\nBy itself, degree is not very informative about what level of degree each student was awarded. We can fill in the rest of this information by changing degree1 from a vector to a factor.\nTo create a factor we use the function factor(). This function can be given the following arguments:\n\nx =: the vector of data which we want to define categories for.\nlevels =: this is a vector of all possible values that the elements in x can take.\nlabels =: this is a vector containing the names of each level of the category.\n\nFor example, to convert the vector degree1 into a factor called degree_factor1 we use:\n\nR CodeOutput\n\n\n\ndegree_factor1 &lt;- factor(x = degree1, levels = 1:3,\n                         labels = c(\"Bachelor's\", \"Master's\", \"PhD\"))\ndegree_factor1\n\n\n\n\n\n[1] Bachelor's Bachelor's Master's   Bachelor's PhD       \nLevels: Bachelor's Master's PhD\n\n\n\n\n\nIf instead, degree had been a character vector stating the level of degree awarded, we can still turn this into a factor so that R knows this is categorical data and there are only three levels we are interested in.\n\nR CodeOutput\n\n\n\ndegree2 &lt;- c(\"Bachelor's\", \"Bachelor's\", \"Master's\", \"Bachelor's\", \"PhD\" )\n\ndegree_factor2 &lt;- factor(x = degree2,\n                         levels = c(\"Bachelor's\", \"Master's\", \"PhD\"))\ndegree_factor2\n\n\n\n\n\n[1] Bachelor's Bachelor's Master's   Bachelor's PhD       \nLevels: Bachelor's Master's PhD\n\n\n\n\n\nYou can also change the labels of the levels used within a pre-existing factor using the levels() function.\n\nR CodeOutput\n\n\n\nlevels(degree_factor2) &lt;- c(\"BSc\", \"MSc\", \"PhD\")\ndegree_factor2\n\n\n\n\n\n[1] BSc BSc MSc BSc PhD\nLevels: BSc MSc PhD\n\n\n\n\n\n\n\nTask\n\n\nThe results from a survey asking students whether statistics is the best subject are shown below. They were given a choice of “Agree”, “Disagree” and “Unsure”.\n\n\n\n\n\nStudent\nAnswer\n\n\n\n\nStudent 1\nAgree\n\n\nStudent 2\nAgree\n\n\nStudent 3\nAgree\n\n\nStudent 4\nUnsure\n\n\nStudent 5\nDisgaree\n\n\n\n\n\nCreate and print a factor, called survey, which contains the answers of these five students as well as the levels of response they could have given.\n\n\n\n\nCreating factors in R is covered in Section 1.9.3 Factors of Probability and Statistics with R.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "02-data.html#sec-df",
    "href": "02-data.html#sec-df",
    "title": "3  Data Structures",
    "section": "3.4 Data frames",
    "text": "3.4 Data frames\nData frames in R are very similar to matrices. The key difference however is that whilst all elements in a matrix must be of the same “mode” (e.g. numeric, character, logical), each column in a data frame can be of a different mode. If you needed to store a numeric vector, a logical vector and a character vector that all relate to the same subjects for example, then a data frame is the way to do this.\nData frames are a very common type of data structure used within R. Most of the data you will see saved in packages, or the data you will use for fitting statistical models will be saved in a data frame.\nTo create a data frame, we can use the function data.frame(). The only arguments needed are the pre-existing vectors that you want to save within the data frame. These all need to be of the same length. Some additional arguments include:\n\nstringAsFactor =: this takes the values TRUE or FALSE and tells R whether any character vectors should be turned into factors. If this argument is excluded, R takes the default value to be FALSE, so character vectors will kept as they are.\nrow.names =: this can be a vector of names you wish to use for the rows of the data frame. By default, R will just number the rows starting from 1.\n\nWe can create a data frame storing information about students’ performance in a course using the following code.\n\nR CodeOutput\n\n\n\npercentage &lt;- c(84, 76, 90, 53, 6, 67)\ngrade &lt;- c(\"A\", \"A\", \"A\", \"C\", \"H\", \"B\")\npass &lt;- c(TRUE, TRUE, TRUE, TRUE, FALSE, TRUE)\n\nperformance &lt;- data.frame(percentage, grade, pass)\nperformance\n\n\n\n\n\n  percentage grade  pass\n1         84     A  TRUE\n2         76     A  TRUE\n3         90     A  TRUE\n4         53     C  TRUE\n5          6     H FALSE\n6         67     B  TRUE\n\n\n\n\n\nWe can see that within the data frame performance, percentage is a numeric vector, grade is a character vector and pass is a logical vector by using the function str().\n\nR CodeOutput\n\n\n\nstr(performance)\n\n\n\n\n\n'data.frame':   6 obs. of  3 variables:\n $ percentage: num  84 76 90 53 6 67\n $ grade     : chr  \"A\" \"A\" \"A\" \"C\" ...\n $ pass      : logi  TRUE TRUE TRUE TRUE FALSE TRUE\n\n\n\n\n\nWe could change grade to be a factor by adding stringsAsFactor = TRUE within the data.frame() function. We can also create a vector of students’ IDs and use this to name the rows of the data frame in the following code.\n\nR CodeOutput\n\n\n\nids &lt;- c(\"ST002\", \"ST014\", \"ST089\", \"ST060\", \"ST034\", \"ST056\")\n\nperformance &lt;- data.frame(percentage, grade, pass,\n                          stringsAsFactors = TRUE, row.names = ids)\nperformance\n\n\n\n\n\n      percentage grade  pass\nST002         84     A  TRUE\nST014         76     A  TRUE\nST089         90     A  TRUE\nST060         53     C  TRUE\nST034          6     H FALSE\nST056         67     B  TRUE\n\n\n\n\n\nNow if we use the str() function, we can see that grade is treated as a factor.\n\nR CodeOutput\n\n\n\nstr(performance)\n\n\n\n\n\n'data.frame':   6 obs. of  3 variables:\n $ percentage: num  84 76 90 53 6 67\n $ grade     : Factor w/ 4 levels \"A\",\"B\",\"C\",\"H\": 1 1 1 3 4 2\n $ pass      : logi  TRUE TRUE TRUE TRUE FALSE TRUE\n\n\n\n\n\n\nExtracting elements\nElements from data frames can be extracted in a couple of ways. For example, we can use square brackets [ ], or we can use the dollar sign operator $.\nFor example, if we wanted to extract just the vector pass from the data frame performance, we can use any of the following code.\n\nR CodeOutput\n\n\n\nperformance[ , \"pass\"]\n\n\n\n\n\n[1]  TRUE  TRUE  TRUE  TRUE FALSE  TRUE\n\n\n\n\n\n\nR CodeOutput\n\n\n\nperformance[ , 3]\n\n\n\n\n\n[1]  TRUE  TRUE  TRUE  TRUE FALSE  TRUE\n\n\n\n\n\n\nR CodeOutput\n\n\n\nperformance$pass\n\n\n\n\n\n[1]  TRUE  TRUE  TRUE  TRUE FALSE  TRUE\n\n\n\n\n\nWhen we use square brackets, we also need to specify which rows we want to exclude as the first entry (before the comma) within the square brackets. In the code above, we haven’t specified any rows, so R shows us all of the rows from performance.\n\n\nTask\n\n\nWrite code to extract only the percentage and the associated grade for the student with ID ST014?\n\n\n\nAn alternative way to easily extract columns from a data frame is to use the attach() function. The only argument needed here is the data frame you want to attach to something called the ‘search path’ in R. This just means that you no longer need to type in the name of the data frame to access its columns.\nBefore we do this, we are going to run the following code to remove the original vectors we created from the Environment tab using the rm() function. We do this so that R doesn’t just show us these pre-existing vectors directly, but instead looks within the data frame performance.\n\nR CodeOutput\n\n\n\nrm(\"percentage\", \"grade\", \"pass\")\n\nattach(performance)\ngrade\n\n\n\n\n\n[1] A A A C H B\nLevels: A B C H\n\n\n\n\n\nThe attach() function is useful if you are going to be using the same data frame over and over, but it is good practice to ‘detach’ it using the detach() function once you no longer need the data frame.\n\nR Code\n\n\n\ndetach(performance)\n\n\n\n\n\n\nUsing packages\nWhen conducting statistical analysis, you won’t often need to create your own data frame of information from scratch - it will most likely already exist in some format somewhere! One place where data might be stored is in the packages you can install and load into R.\nWe have already installed and loaded the package PASWR2 in Section 2. We can now see a list of the data frames stored in the PASWR2 package by using the following code.\n\nR Code\n\n\n\ndata(package = \"PASWR2\")\n\n\n\n\nWe can see more information about the data stored in any of these data sets using the help() function. For example, if we wanted to know what the data in the data frame RAT related to, we could use the following code.\n\nR Code\n\n\n\nhelp(\"RAT\")\n\n\n\n\nTo view an extract of this data frame, we can use the function head() and provide as an argument the name of the data frame. This will show us the first 6 rows of a data frame by default.\n\nR CodeOutput\n\n\n\nhead(RAT)\n\n\n\n\n\n  survival.time\n1           152\n2           152\n3           115\n4           109\n5           137\n6            88\n\n\n\n\n\nTo save a data frame from a package in our own Environment tab, we use the function data(). This will read in the data frame and means we can use it as we would any other data frame that we had created ourselves.\n\nR Code\n\n\n\ndata(\"RAT\")\n\n\n\n\n\n\nTask\n\n\nThe package PASWR2 contains a data set called WAIT. What do the wait times saved in this data set relate to? \n\n\n\n\nTask\n\n\nWrite code to first view the top 5 rows of the data frame WAIT and then load it into your Environment.\n\n\n\n\nAll of this information is covered with further examples in Section 1.9.5 Data Frames of Probability and Statistics with R.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Data Structures</span>"
    ]
  },
  {
    "objectID": "03-exercises.html",
    "href": "03-exercises.html",
    "title": "4  Further Exercises",
    "section": "",
    "text": "Exercise 1\nTable 4.1 below shows the annual mean temperature (in degrees Celsius) at 4 different locations along the River Dee for each year from 2015 to 2021. These data have been collected under the Scotland River Temperature Monitoring Network (SRTMN) project.\nTable 4.1: Recorded annual mean temperatures across the River Dee in the years 2015 to 2021.\n\n\n\n\n\n\n\n2015\n2016\n2017\n2018\n2019\n2020\n2021\n\n\n\n\nSite 1\nNA\n6.83\n7.01\n7.03\n6.88\n7.06\n7.28\n\n\nSite 2\n5.79\n6.00\n6.25\n6.23\n6.13\n6.25\n6.48\n\n\nSite 3\n5.77\n6.28\n6.53\n6.81\n6.36\n6.55\n6.59\n\n\nSite 4\n6.14\n6.65\n6.83\n7.07\n6.58\n6.86\n6.92\nSave these data in a matrix called temps and make sure to rename the rows and columns of this matrix so they match the row and column names shown in Table 4.1.\nCalculate the mean of all the temperatures from Site 3 across all seven years.\nCalculate the mean of the temperatures across all four sites in 2015.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Further Exercises</span>"
    ]
  },
  {
    "objectID": "03-exercises.html#exercise-2",
    "href": "03-exercises.html#exercise-2",
    "title": "4  Further Exercises",
    "section": "Exercise 2",
    "text": "Exercise 2\nMake sure the package PASWR2 is installed and loaded in your current RStudio session. From this package, save the data frame SWIMTIMES into your Environment tab. This data set gives the improvement time (in seconds) for 28 swimmers who were randomly assigned to one of two different diets (see more by running the code help(\"SWIMTIMES\")).\nExplore the structure of the variables of this data set and change the labels for the levels of the factor diet to be high and low.\nWhat is the mean improvement time for swimmers who were on a high fat diet?",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Further Exercises</span>"
    ]
  },
  {
    "objectID": "03-exercises.html#exercise-3",
    "href": "03-exercises.html#exercise-3",
    "title": "4  Further Exercises",
    "section": "Exercise 3",
    "text": "Exercise 3\nMercedes has decided to keep track of different aspects of their life. Below are their notes recording their daily steps, some of their expenses and their most recent exam results.\n\n\n\n\n\n\n\n\n\nCreate three separate data frames, one for each of these notes, that stores the information shown above. Call them steps, expenses and grades respectively.\nThen, combine these data frames into a single list so that Mercedes can easily continue to track these parts of their life.\nCan you write code to show only the expenses from 14/08, using the list you have created?",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Further Exercises</span>"
    ]
  },
  {
    "objectID": "04-dimensions.html",
    "href": "04-dimensions.html",
    "title": "Appendix A — Dimensions of matrices",
    "section": "",
    "text": "To check the dimensions of a matrix (or an array), we use the function dim(). For matrices, this will return a vector of length 2 where the first value is the number of rows and the second value is the number of columns.\nFor example we can see that M1 has 6 rows and 4 columns using the following code.\n\nR CodeOutput\n\n\n\ndim(M1)\n\n\n\n\n\n[1] 6 4\n\n\n\n\n\n\nWhen extracting an entire row or column using [ ], the object that R returns is a vector rather than a matrix. This means that we can’t use some functions that only work for matrices (or arrays).\nFor example, the code below returns the value NULL when using the dim() function. dim() should return the dimensions of an array, but since the extracted row for births in Edinburgh is a vector, there are no dimensions to return.\n\nR CodeOutput\n\n\n\ndim(births[\"Edinburgh\", ])\n\n\n\n\n\nNULL\n\n\n\n\n\nIf we want to know how many elements are in a vector, we use the function length().\n\nR CodeOutput\n\n\n\nlength(births[\"Edinburgh\", ])\n\n\n\n\n\n[1] 3\n\n\n\n\n\nWe can force the output from subseting a matrix/array to be a matrix/array by including a third argument, drop = FALSE, within the square brackets to keep the returned row as a matrix/array.\n\nR CodeOutput\n\n\n\ndim(births[\"Edinburgh\", , drop = FALSE])\n\n\n\n\n\n[1] 1 3\n\n\n\n\n\nNow we can see that the row is seen as a 1 \\(\\times\\) 3 matrix by R.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Dimensions of matrices</span>"
    ]
  },
  {
    "objectID": "05-matrix_multip.html",
    "href": "05-matrix_multip.html",
    "title": "Appendix B — Vector/Matrix multiplication",
    "section": "",
    "text": "R can be used to complete vector and matrix multiplication. The operator used for this is %*%. For example, for the following matrix and vector,\n\\[\n\\boldsymbol{X}=\\begin{bmatrix}2&4&-1\\\\3&2&2\\\\1&2&-1\\end{bmatrix},\\,\\,\\,\\,\\boldsymbol{y}=\\begin{bmatrix}1\\\\1\\\\3\\end{bmatrix}\n\\]\nThe solution to \\(\\boldsymbol{X}\\times\\boldsymbol{y}\\) can be found using the following code.\n\nR CodeOutput\n\n\n\nX &lt;- matrix(data = c(2, 4, -1, 3, 2, 2, 1, 2, -1), nrow = 3, byrow = TRUE)\ny &lt;- matrix(data = c(1, 1, 3), nrow = 3, byrow = TRUE)\n\nX%*%y\n\n\n\n\n\n     [,1]\n[1,]    3\n[2,]   11\n[3,]    0\n\n\n\n\n\nIf instead we wanted to calculate \\(\\boldsymbol{y}^\\intercal\\times\\boldsymbol{X}\\) we would first have to transpose y. Matrices can be transposed using the function t().\n\nR CodeOutput\n\n\n\nt(y)%*%X\n\n\n\n\n\n     [,1] [,2] [,3]\n[1,]    8   12   -2\n\n\n\n\n\nR can also be used to solve a system of equations. For example, we have just seen that,\n\\[\n\\begin{aligned}\n(2\\times 1)+(4\\times 1)+(-1\\times 3)&=3\\\\\n(3\\times 1)+(2\\times 1)+(2\\times 3)&=11\\\\\n(1\\times 1)+(2\\times 1)+(-1\\times 3)&=0\n\\end{aligned}\n\\]\nBut suppose we didn’t know the vector \\(\\boldsymbol{y}\\), and instead were given the system of equations,\n\\[\n\\begin{aligned}\n2x+4y-z&=3\\\\\n3x+2y+2z&=11\\\\\nx+2y-z&=0\n\\end{aligned}\n\\]\nThis can also be represented as,\n\\[\n\\boldsymbol{Xy}=\\boldsymbol{z},\\,\\mbox{ where }\n\\boldsymbol{X}=\\begin{bmatrix}2&4&-1\\\\3&2&2\\\\1&2&-1\\end{bmatrix},\\,\\,\\,\\,\\boldsymbol{y}=\\begin{bmatrix}x\\\\y\\\\z\\end{bmatrix},\\mbox{ and }\\boldsymbol{z}=\\begin{bmatrix}3\\\\11\\\\0\\end{bmatrix}\n\\]\nWe can then use R to solve this system of equations using the solve() function. We need to give solve() the matrix of coefficients, \\(\\boldsymbol{X}\\), and the vector \\(\\boldsymbol{z}\\).\n\nR CodeOutput\n\n\n\nz &lt;- matrix(data = c(3, 11, 0), nrow = 3, byrow = TRUE)\n\nsolve(X, z)\n\n\n\n\n\n     [,1]\n[1,]    1\n[2,]    1\n[3,]    3\n\n\n\n\n\nThis then gives the solution \\(\\boldsymbol{y}=\\begin{bmatrix}1&1&3\\end{bmatrix}^\\intercal\\), which is what we expected to see.\nIt is also possible to use the solve() function to simply find the inverse of a matrix. This is done by providing it with only one argument - the matrix to be inverted. For example, the code below returns the inverse of the matrix \\(X\\).\n\nR CodeOutput\n\n\n\nsolve(X)\n\n\n\n\n\n      [,1]  [,2]  [,3]\n[1,] -1.50  0.50  2.50\n[2,]  1.25 -0.25 -1.75\n[3,]  1.00  0.00 -2.00\n\n\n\n\n\nWe can see that,\n\\[\n\\boldsymbol{X}^{-1}=\\begin{bmatrix}-1.50&0.50&2.50\\\\1.25&-0.25&-1.75\\\\1.00&0.00&-2.00\\end{bmatrix}\n\\]\n\nThere are additional details and examples of using matrices in R in Sections 1.9.1 Arrays and Matrices and 1.9.2 Vector and Matrix Operations of Probability and Statistics with R.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Vector/Matrix multiplication</span>"
    ]
  },
  {
    "objectID": "06-lists.html",
    "href": "06-lists.html",
    "title": "Appendix C — Lists",
    "section": "",
    "text": "Lists are objects in R that bring together elements of different modes (for example character, numeric or logical vectors or even matrices or arrays) into the same object. Lists are created using the list() function which doesn’t have any particular arguments required. Instead, the name of each element is given as well as what this element should be - this could be a vector, a matrix or an array.\nFor example, we could save information about the movie Titanic in a list using the following code.\n\nR CodeOutput\n\n\n\ntitanic &lt;- list(director = \"James Cameron\",\n                actors = c(\"Leonardo DiCaprio\", \"Kate Winslet\"),\n                runtime = \"3 hours 14 minutes\",\n                release.date = \"23/01/1998\",\n                budget = 200000000,\n                gross.profit = 2222985568,\n                production.companies = c(\"Twentieth Century Fox\",\n                                         \"Paramount Pictures\",\n                                         \"Lightstorm Entertainment\"))\ntitanic\n\n\n\n\n\n$director\n[1] \"James Cameron\"\n\n$actors\n[1] \"Leonardo DiCaprio\" \"Kate Winslet\"     \n\n$runtime\n[1] \"3 hours 14 minutes\"\n\n$release.date\n[1] \"23/01/1998\"\n\n$budget\n[1] 2e+08\n\n$gross.profit\n[1] 2222985568\n\n$production.companies\n[1] \"Twentieth Century Fox\"    \"Paramount Pictures\"      \n[3] \"Lightstorm Entertainment\"\n\n\n\n\n\nThe elements of a list can be accessed using either double square brackets [[ ]], or the $ operator (when the elements are named). For example, if we wanted to extract the release date from titanic, then we can use any of the following code.\n\nR CodeOutput\n\n\n\ntitanic[[\"release.date\"]]\n\n\n\n\n\n[1] \"23/01/1998\"\n\n\n\n\n\n\nR CodeOutput\n\n\n\ntitanic[[4]]\n\n\n\n\n\n[1] \"23/01/1998\"\n\n\n\n\n\n\nR CodeOutput\n\n\n\ntitanic$release.date\n\n\n\n\n\n[1] \"23/01/1998\"\n\n\n\n\n\nWe could also be more specific and extract a particular entry from one of the elements of the list using single square brackets, [ ], after the double square brackets or $ operator. For example, if we wanted to know who the second billed actor is, then we can use any of the following lines of code.\n\nR CodeOutput\n\n\n\ntitanic[[\"actors\"]][2]\n\n\n\n\n\n[1] \"Kate Winslet\"\n\n\n\n\n\n\nR CodeOutput\n\n\n\ntitanic[[2]][2]\n\n\n\n\n\n[1] \"Kate Winslet\"\n\n\n\n\n\n\nR CodeOutput\n\n\n\ntitanic$actors[2]\n\n\n\n\n\n[1] \"Kate Winslet\"\n\n\n\n\n\nIf you are unsure of the names of all of the elements of a list, then the names() function is useful.\n\nR CodeOutput\n\n\n\nnames(titanic)\n\n\n\n\n\n[1] \"director\"             \"actors\"               \"runtime\"             \n[4] \"release.date\"         \"budget\"               \"gross.profit\"        \n[7] \"production.companies\"\n\n\n\n\n\n\nYou can see other examples of how lists can be used in Section 1.9.4 Lists of Probability and Statistics with R.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Lists</span>"
    ]
  }
]